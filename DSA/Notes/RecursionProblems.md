#### Recursion Problems

Here are some common recursion problems along with their explanations and C# implementations.

##### **Remove middle element from stack using recursion**

```csharp
public class RecursionExamples
{
    // Function to remove the middle element from the stack
    public static void RemoveMiddleElement(Stack<int> stack, int currentIndex, int middleIndex)
    {
        // Base Case: If current index is equal to middle index, pop the element
        if (currentIndex == middleIndex)
        {
            stack.Pop();
            return;
        }

        // Store the top element and pop it
        int topElement = stack.Pop();

        // Recursive call
        RemoveMiddleElement(stack, currentIndex + 1, middleIndex);

        // Push the stored element back onto the stack
        stack.Push(topElement);
    }
}
```

##### **Sort a stack using recursion**

```csharp
public class RecursionExamples
{
    // Function to insert an element in sorted order
    public static void SortedInsert(Stack<int> stack, int element)
    {
        // Base Case: If stack is empty or top element is less than or equal to the element
        if (stack.Count == 0 || stack.Peek() <= element)
        {
            stack.Push(element);
            return;
        }

        // Store the top element and pop it
        int topElement = stack.Pop();

        // Recursive call
        SortedInsert(stack, element);

        // Push the stored element back onto the stack
        stack.Push(topElement);
    }

    // Function to sort the stack
    public static void SortStack(Stack<int> stack)
    {
        // Base Case: If stack is empty
        if (stack.Count == 0)
        {
            return;
        }

        // Store the top element and pop it
        int topElement = stack.Pop();

        // Recursive call
        SortStack(stack);

        // Insert the stored element in sorted order
        SortedInsert(stack, topElement);
    }
} 
```

##### **Reverse a stack using recursion**

```csharp
public class RecursionExamples
{
    // Function to insert an element at the bottom of the stack
    public static void InsertAtBottom(Stack<int> stack, int element)
    {
        // Base Case: If stack is empty, push the element
        if (stack.Count == 0)
        {
            stack.Push(element);
            return;
        }

        // Store the top element and pop it
        int topElement = stack.Pop();

        // Recursive call
        InsertAtBottom(stack, element);

        // Push the stored element back onto the stack
        stack.Push(topElement);
    }

    // Function to reverse the stack
    public static void ReverseStack(Stack<int> stack)
    {
        // Base Case: If stack is empty
        if (stack.Count == 0)
        {
            return;
        }

        // Store the top element and pop it
        int topElement = stack.Pop();

        // Recursive call
        ReverseStack(stack);

        // Insert the stored element at the bottom of the stack
        InsertAtBottom(stack, topElement);
    }
}
```

##### **[Kth Symbol in Grammar](https://leetcode.com/problems/k-th-symbol-in-grammar/)**

```* The Kth symbol in grammar problem involves finding the Kth symbol in the Nth row of a specific grammar sequence.
* The sequence starts with "0" in the first row, and each subsequent row is generated by replacing "0" with "01" and "1" with "10".
* The problem can be solved using recursion by determining the parent symbol and its position.
* **Example Test Case:**
  * Input: N = 4, K = 5
  * Output: 1
  * Explanation: The 4th row is "01101001", and the 5th symbol is "1".
  ```

```csharp
public class RecursionExamples
{
    // Function to find the Kth symbol in grammar
    public static int KthSymbol(int n, int k)
    {
        // Base Case: First row, first symbol is 0
        if (n == 1 && k == 1)
        {
            return 0;
        }

        // Find the parent symbol's position
        int mid = (int)Math.Pow(2, n - 1) / 2;

        if (k <= mid)
        {
            // If k is in the first half, it is the same as the parent
            return KthSymbol(n - 1, k);
        }
        else
        {
            // If k is in the second half, it is the complement of the parent
            return 1 - KthSymbol(n - 1, k - mid);
        }
    }
}
```

##### **[Tower of Hanoi](https://leetcode.com/problems/tower-of-hanoi/)**

```* The Tower of Hanoi is a classic problem that involves moving a set of disks from one peg to another, following specific rules. 
* The rules are:
  * Only one disk can be moved at a time.
  * Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty peg.
  * No larger disk may be placed on top of a smaller disk.
  ```

```csharp
public class RecursionExamples
{
    // Function to solve Tower of Hanoi problem
    public static void TowerOfHanoi(int n, char source, char destination, char auxiliary)
    {
        // Base Case: If there is only one disk, move it directly from source to destination
        if (n == 1)
        {
            Console.WriteLine($"Move disk 1 from rod {source} to rod {destination}");
            return;
        }

        // Move n-1 disks from source to auxiliary peg
        TowerOfHanoi(n - 1, source, auxiliary, destination);

        // Move the nth disk from source to destination peg
        Console.WriteLine($"Move disk {n} from rod {source} to rod {destination}");

        // Move the n-1 disks from auxiliary to destination peg
        TowerOfHanoi(n - 1, auxiliary, destination, source);
    }
}
```
##### **[Print unique subsets of an Array](https://leetcode.com/problems/subsets-ii/)**

```csharp

class RecursionExamples
{
    public static void GenerateUniqueSubsets(string str, int index, string current, HashSet<string> result)
    {
        // Base Case: If index reaches the end of the string
        if (index == str.Length)
        {
            result.Add(current); // Add current subset to result set
            return;
        }

        // Choice 1: Include the current character
        GenerateUniqueSubsets(str, index + 1, current + str[index], result);

        // Choice 2: Exclude the current character
        GenerateUniqueSubsets(str, index + 1, current, result);
    }

    public static List<string> GetUniqueSubsets(string str)
    {
        HashSet<string> result = new HashSet<string>();
        GenerateUniqueSubsets(str, 0, "", result);
        return new List<string>(result);
    }
}
```

##### **[Permutations with letter case](https://leetcode.com/problems/letter-case-permutation/)**

```csharp

class RecursionExamples
{
    public static void LetterCasePermutation(string str, int index, string current, List<string> result)
    {
        // Base Case: If index reaches the end of the string
        if (index == str.Length)
        {
            result.Add(current); // Add current permutation to result list
            return;
        }

        char ch = str[index];

        // If the character is a letter, we have two choices
        if (char.IsLetter(ch))
        {
            // Choice 1: Include the lowercase version of the character
            LetterCasePermutation(str, index + 1, current + char.ToLower(ch), result);

            // Choice 2: Include the uppercase version of the character
            LetterCasePermutation(str, index + 1, current + char.ToUpper(ch), result);
        }
        else
        {
            // If it's not a letter, just include it as is
            LetterCasePermutation(str, index + 1, current + ch, result);
        }
    }

    public static List<string> GetLetterCasePermutations(string str)
    {
        List<string> result = new List<string>();
        LetterCasePermutation(str, 0, "", result);
        return result;
    }
}
```

##### **[Generate All balanced Parentheses](https://leetcode.com/problems/generate-parentheses/)**

```csharp
class RecursionExamples
{
    public static void GenerateParentheses(int open, int close, string current, List<string> result)
    {
        // Base Case: If no more open or close parentheses left to add
        if (open == 0 && close == 0)
        {
            result.Add(current); // Add current combination to result list
            return;
        }

        // If we can still add an open parenthesis
        if (open > 0)
        {
            GenerateParentheses(open - 1, close, current + "(", result);
        }

        // If we can add a close parenthesis (only if there are more close than open)
        if (close > open)
        {
            GenerateParentheses(open, close - 1, current + ")", result);
        }
    }

    public static List<string> GetBalancedParentheses(int n)
    {
        List<string> result = new List<string>();
        GenerateParentheses(n, n, "", result);
        return result;
    }
}
```

##### **[Josephus Problem](https://www.geeksforgeeks.org/dsa/josephus-problem/)**

```
There are N people standing in a circle waiting to be executed. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, a certain number of people are skipped and the next person is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last person remains, who is given freedom. 

Given the total number of persons N and a number k which indicates that k-1 persons are skipped and the kth person is killed in a circle. The task is to choose the person in the initial circle that survives.

Examples:

Input: N = 5 and k = 2
Output: 3
Explanation: Firstly, the person at position 2 is killed, 
then the person at position 4 is killed, then the person at position 1 is killed. 
Finally, the person at position 5 is killed. So the person at position 3 survives. 

Input: N = 7 and k = 3
Output: 4
Explanations: The persons at positions 3, 6, 2, 7, 5, and 1 are killed in order, 
and the person at position 4 survives.

Input: N = 6 and k = 2
Output: 5
Explanation: The persons at positions 2, 4, 6, 3, and 1 are killed in order, and the person at position 5 survives.
```

```csharp
class RecursionExamples
{
    // Function to solve Josephus Problem
    public static int Josephus(int n, int k)
    {
        // Base Case: If there is only one person, they are the survivor
        if (n == 1)
        {
            return 0; // Using 0-based indexing
        }

        // Recursive call: Find the position of the survivor in the reduced problem
        int survivor = Josephus(n - 1, k);

        // Adjust the position to account for the current number of people
        return (survivor + k) % n;
    }

    public static int GetJosephusPosition(int n, int k)
    {
        // Convert to 1-based indexing by adding 1
        return Josephus(n, k) + 1;
    }
}
```

##### **[Generate all the binary strings of n bits](https://www.geeksforgeeks.org/dsa/generate-all-the-binary-strings-of-n-bits/)**

```csharp
class RecursionExamples
{
    public static void GenerateBinaryStrings(int n, string current, List<string> result)
    {
        // Base Case: If the length of the current string is equal to n
        if (current.Length == n)
        {
            result.Add(current); // Add current binary string to result list
            return;
        }

        // Choice 1: Append '0' to the current string
        GenerateBinaryStrings(n, current + "0", result);

        // Choice 2: Append '1' to the current string
        GenerateBinaryStrings(n, current + "1", result);
    }

    public static List<string> GetBinaryStrings(int n)
    {
        List<string> result = new List<string>();
        GenerateBinaryStrings(n, "", result);
        return result;
    }
}
```