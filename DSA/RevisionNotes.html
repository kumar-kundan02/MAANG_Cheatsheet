<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Revision Notes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fff;
            padding: 40px;
            max-width: 1000px;
            margin: 0 auto;
        }
        
        h1 {
            color: #1a1a1a;
            font-size: 2.5em;
            margin-bottom: 10px;
            border-bottom: 3px solid #0066cc;
            padding-bottom: 15px;
        }
        
        .header-subtitle {
            color: #cc0000;
            font-weight: bold;
            margin-bottom: 30px;
            font-size: 0.9em;
        }
        
        h2, h3, h4, h5, h6 {
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        h2 {
            font-size: 1.8em;
        }
        
        h3 {
            font-size: 1.5em;
        }
        
        h4 {
            font-size: 1.3em;
        }
        
        h5 {
            font-size: 1.1em;
            margin: 10px 0 5px 0;
        }
        
        blockquote {
            border-left: 4px solid #0066cc;
            padding-left: 15px;
            margin: 5px 0 10px 0;
            color: #555;
            font-style: italic;
            background-color: #f9f9f9;
            padding: 10px 15px;
        }
        
        pre {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 12px;
            overflow-x: auto;
            margin: 0 0 15px 0;
            font-size: 12px;
            line-height: 1.4;
        }
        
        code {
            font-family: "Courier New", Courier, monospace;
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
        }
        
        hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 30px 0;
        }
        
        @media print {
            body {
                padding: 20px;
            }
            
            h1 {
                page-break-after: avoid;
            }
            
            h2 {
                page-break-after: avoid;
            }
            
            h3, h4 {
                page-break-before: always;
                page-break-after: avoid;
            }
            
            h5 {
                page-break-inside: avoid;
                page-break-after: avoid;
                margin: 0 0 5px 0;
            }
            
            blockquote {
                page-break-inside: avoid;
                margin: 0 0 10px 0;
                padding: 10px 15px;
            }
            
            pre {
                page-break-inside: avoid;
                margin: 0 0 20px 0;
            }
            
            hr {
                page-break-after: avoid;
            }
        }
    </style>
</head>
<body>
    <h1>üìö DSA Revision Notes</h1>
    <div class="header-subtitle">Last Updated: January 12, 2026</div>
    <hr>
    
<h2 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 1. BST</h2>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>1.1. Check If BST</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root node of a binary tree. Return true if the given binary tree is a binary search tree(BST) else false.
A valid BST is defined as follows:
The left subtree of a node contains only nodes with key strictly less than the node&#x27;s key.
The right subtree of a node contains only nodes with key strictly greater than the node&#x27;s key.
Both the left and right subtrees must also be binary search trees.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int data;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.data = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
   <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">bool</span> IsBST(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#0066cc;font-weight:bold;">return</span> ValidateBST(root, <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;());

    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">bool</span> ValidateBST(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; lst)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> true;

        <span style="color:#0066cc;font-weight:bold;">if</span>(!ValidateBST(root.left, lst)) 
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> false;
        }
        <span style="color:#0066cc;font-weight:bold;">if</span>(lst.Count &gt; <span style="color:#098658;">0</span> &amp;&amp; root.data &lt;= lst[lst.Count-<span style="color:#098658;">1</span>])
            <span style="color:#0066cc;font-weight:bold;">return</span> false;
        lst.Add(root.data);
        <span style="color:#0066cc;font-weight:bold;">return</span> ValidateBST(root.right, lst);
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>1.2. Find Ceil And Floor</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a root of binary search tree and a key(node) value, find the floor and ceil value for that particular key value.

Floor Value Node: Node with the greatest data lesser than or equal to the key value. 
Ceil Value Node: Node with the smallest data larger than or equal to the key value.
If a particular floor or ceil value is not present then output -1.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int data;
 *     public TreeNode left;
 *     public TreeNode right;
 *      public TreeNode(int val) {
 *          data = val;
 *          left = null;
 *          right = null;
 *      }
 * };
 **/</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; FloorCeilOfBST(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#0066cc;font-weight:bold;">int</span> key) {
        <span style="color:#008000;">// Approach: I need to find the floor and ceil separately</span>
        <span style="color:#008000;">// We need to keep moving untill encounter either exactly key or null</span>

        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
        <span style="color:#0066cc;font-weight:bold;">int</span> floor = -<span style="color:#098658;">1</span>, ceil = -<span style="color:#098658;">1</span>;
        <span style="color:#008000;font-weight:bold;">TreeNode</span> currentNode = root;

        <span style="color:#008000;">// find floor</span>
        <span style="color:#0066cc;font-weight:bold;">while</span>(currentNode != null)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(currentNode.data == key)
            {
                floor = currentNode.data;
                break;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span>(key &gt; currentNode.data)
            {
                floor = currentNode.data;
                currentNode = currentNode.right;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span>
            {
                currentNode = currentNode.left;
            }
        }

        <span style="color:#008000;">// Finding Ceil</span>
        currentNode = root;
        <span style="color:#0066cc;font-weight:bold;">while</span>(currentNode != null)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(currentNode.data == key)
            {
                ceil = currentNode.data;
                break;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span>(key &lt; currentNode.data)
            {
                ceil = currentNode.data;
                currentNode = currentNode.left;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span>
            {
                currentNode = currentNode.right;
            }
        }

        res.Add(floor);
        res.Add(ceil);

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>1.3. Insert Node</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root node of a binary search tree (BST) and a value val to insert into the tree. Return the root node of the BST after the insertion.
It is guaranteed that the new value does not exist in the original BST. Note that the compiler output shows true if the node is added correctly, else false.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>

<span style="color:#008000;">// Using Recursion</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">TreeNode</span> InsertIntoBST(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#0066cc;font-weight:bold;">int</span> val) {

        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">TreeNode</span>(val);
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(val &lt; root.val)
        {
            root.left = InsertIntoBST(root.left, val);
        }
        <span style="color:#0066cc;font-weight:bold;">else</span>
        {
            root.right = InsertIntoBST(root.right, val);
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> root;
    }
}

<span style="color:#008000;">// Using Iterative Approach</span>
<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">TreeNode</span> InsertIntoBST(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#0066cc;font-weight:bold;">int</span> val)
    {
        <span style="color:#008000;">// Your code goes here</span>

        <span style="color:#008000;font-weight:bold;">TreeNode</span> current = root;
        <span style="color:#008000;font-weight:bold;">TreeNode</span> lastNode = null;
        <span style="color:#008000;font-weight:bold;">TreeNode</span> nodeToAdd = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">TreeNode</span>(val);

        <span style="color:#0066cc;font-weight:bold;">while</span> (current != null)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span> (val &lt; current.val)
            {
                lastNode = current;
                current = current.left;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span> (val &gt; current.val)
            {
                lastNode = current;
                current = current.right;
            }
        }

        <span style="color:#0066cc;font-weight:bold;">if</span> (val &gt; lastNode.val)
        {
            lastNode.right = nodeToAdd;
        }
        <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span> (val &lt; lastNode.val)
        {
            lastNode.left = nodeToAdd;
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> root;

    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>1.4. Kth Smallest Largest</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root node of a binary search tree (BST) and an integer k.
Return the kth smallest and largest value (1-indexed) of all values of the nodes in the tree.
Return the 1st integer as kth smallest and 2nd integer as kth largest in the returned array.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/** Definition for a binary tree node.
* public class TreeNode {
*     public int Data;
*     public TreeNode Left;
*     public TreeNode Right;
*     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {
*       Data = val;
*       Left = left;
*       Right = right;
*   }
*}
*/</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; KLargesSmall(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#0066cc;font-weight:bold;">int</span> k) {
        <span style="color:#008000;">// Do the Inorder traversal to get the sorted Array</span>
        <span style="color:#008000;">// Find the kth smallest and largest from the array</span>

        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; lst = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
        Traverse(root, lst);

        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
        res.Add(lst[k-<span style="color:#098658;">1</span>]);
        res.Add(lst[lst.Count - k]);

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> Traverse(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; lst)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null)
            <span style="color:#0066cc;font-weight:bold;">return</span>;
        
        Traverse(root.Left, lst);
        lst.Add(root.Data);
        Traverse(root.Right, lst);
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h2 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 2. Dynamic Programming</h2>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.1. 0_1_Knapsack</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two integer arrays, val and wt, each of size N, which represent the values 
and weights of N items respectively, and an integer W representing the maximum 
capacity of a knapsack, determine the maximum value achievable by selecting a subset 
of the items such that the total weight of the selected items does not exceed 
the knapsack capacity W.

Each item can either be picked in its entirety or not picked at all (0-1 property). 
The goal is to maximize the sum of the values of the selected items while keeping 
the total weight within the knapsack&#x27;s capacity.

Examples:
Input: val = [60, 100, 120], wt = [10, 20, 30], W = 50
Output: 220

Explanation: Select items with weights 20 and 30 for a total value of 100 + 120 = 220.

Input: val = [10, 40, 30, 50], wt = [5, 4, 6, 3], W = 10
Output: 90

Explanation: Select items with weights 4 and 3 for a total value of 40 + 50 = 90.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> knapsack01(<span style="color:#0066cc;font-weight:bold;">int</span>[] wt, <span style="color:#0066cc;font-weight:bold;">int</span>[] val, <span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span> W)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n+<span style="color:#098658;">1</span>, W+<span style="color:#098658;">1</span>];

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(wt, val,W, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] wt, <span style="color:#0066cc;font-weight:bold;">int</span>[] val, <span style="color:#0066cc;font-weight:bold;">int</span> cw, <span style="color:#0066cc;font-weight:bold;">int</span> pos, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(cw &lt;= <span style="color:#098658;">0</span> || pos &gt;= wt.Length)
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[pos,cw] != <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[pos,cw];

        <span style="color:#0066cc;font-weight:bold;">int</span> p1 = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">if</span>(cw &gt;= wt[pos])
        {
            p1 = val[pos] + Solve(wt, val, cw-wt[pos], pos+<span style="color:#098658;">1</span>, dp);
        }

        <span style="color:#0066cc;font-weight:bold;">int</span> p2 = Solve(wt, val, cw, pos+<span style="color:#098658;">1</span>, dp);
        dp[pos, cw] = Math.Max(p1, p2); 

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[pos,cw];
        
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.2. Ninja Training</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
A ninja has planned a n-day training schedule. Each day he has to perform one of three activities - running, stealth training, or fighting practice. The same activity cannot be done on two consecutive days and the ninja earns a specific number of merit points, based on the activity and the given day.

Given a n x 3-sized matrix, where matrix[i][0], matrix[i][1], and matrix[i][2], represent the merit points associated with running, stealth and fighting practice, on the (i+1)th day respectively. Return the maximum possible merit points that the ninja can earn.

Examples:
Input: matrix = [[10, 40, 70], [20, 50, 80], [30, 60, 90]]

Output: 210

Explanation:

Day 1: fighting practice = 70

Day 2: stealth training = 50

Day 3: fighting practice = 90

Total = 70 + 50 + 90 = 210

This gives the optimal points.

Input: matrix = [[70, 40, 10], [180, 20, 5], [200, 60, 30]]

Output: 290

Explanation:

Day 1: running = 70

Day 2: stealth training = 20

Day 3: running = 200

Total = 70 + 20 + 200 = 290

This gives the optimal points.

Input: matrix = [[20, 10, 10], [20, 10, 10], [20, 30, 10]]

Output:
60
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> NinjaTraining(<span style="color:#0066cc;font-weight:bold;">int</span>[][] matrix)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = matrix.Length, n = matrix[<span style="color:#098658;">0</span>].Length;
        <span style="color:#0066cc;font-weight:bold;">int</span> res = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m+<span style="color:#098658;">1</span>,n];
        
        <span style="color:#008000;">// Call for all the combinations</span>
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;<span style="color:#098658;">3</span>; i++)
        {
            ResetDpArray(dp, m+<span style="color:#098658;">1</span>, n);
            res = Math.Max(res, Solve(matrix, <span style="color:#098658;">0</span>, i, dp)); 
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> ResetDpArray(<span style="color:#0066cc;font-weight:bold;">int</span>[,] dp, <span style="color:#0066cc;font-weight:bold;">int</span> m, <span style="color:#0066cc;font-weight:bold;">int</span> n)
    {
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[][] matrix,  <span style="color:#0066cc;font-weight:bold;">int</span> idx, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(idx == matrix.Length)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[idx,j] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[idx,j];

        <span style="color:#008000;">// explore all the choices</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> p = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> k=<span style="color:#098658;">0</span>; k&lt;<span style="color:#098658;">3</span>; k++)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(k == j)
                continue;
            p = Math.Max(matrix[idx][j] + Solve(matrix, idx+<span style="color:#098658;">1</span>, k, dp), p);
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[idx,j] = p;
    }
}</pre>
<h3 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 2.3. 1 D_DP</h3>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.3.1. Climb Stairs</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an integer n, there is a staircase with n steps, starting from the 0th step.



Determine the number of unique ways to reach the nth step, given that each move can be either 1 or 2 steps at a time.


Examples:
Input: n = 2

Output: 2

Explanation:

There are 2 unique ways to climb to the 2nd step:

1) 1 step + 1 step

2) 2 steps

Input: n = 3

Output: 3

Explanation:

There are 3 unique ways to climb to the 3rd step:

1) 1 step + 1 step + 1 step

2) 2 steps + 1 step

3) 1 step + 2 steps
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> climbStairs(<span style="color:#0066cc;font-weight:bold;">int</span> n) {
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n+<span style="color:#098658;">1</span>];
        <span style="color:#008000;font-weight:bold;">Array</span>.Fill(dp, -<span style="color:#098658;">1</span>);
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[n] = Solve(n, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span>[] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(n == <span style="color:#098658;">0</span>) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">1</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(n &lt; <span style="color:#098658;">0</span>) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[n] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[n];
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[n] = Solve(n-<span style="color:#098658;">1</span>, dp) + Solve(n-<span style="color:#098658;">2</span>, dp);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.3.2. Frog Jump</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
A frog wants to climb a staircase with n steps. Given an integer array heights, where heights[i] contains the height of the ith step.

To jump from the ith step to the jth step, the frog requires abs(heights[i] - heights[j]) energy, where abs() denotes the absolute difference. The frog can jump from any step either one or two steps, provided it exists.

Return the minimum amount of energy required by the frog to go from the 0th step to the (n-1)th step.

Examples:
Input: heights = [2, 1, 3, 5, 4]

Output: 2

Explanation:

One possible route can be,

0th step -&gt; 2nd Step = abs(2 - 3) = 1

2nd step -&gt; 4th step = abs(3 - 4) = 1

Total = 1 + 1 = 2.

Input: heights = [7, 5, 1, 2, 6]

Output: 9

Explanation:

One possible route can be,

0th step -&gt; 1st Step = abs(7 - 5) = 2

1st step -&gt; 3rd step = abs(5 - 2) = 3

3rd step -&gt; 4th step = abs(2 - 6) = 4

Total = 2 + 3 + 4 = 9.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> frogJump(<span style="color:#0066cc;font-weight:bold;">int</span>[] heights)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> n = heights.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n];
        <span style="color:#008000;font-weight:bold;">Array</span>.Fill(dp, -<span style="color:#098658;">1</span>);

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(heights, n-<span style="color:#098658;">1</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] heights, <span style="color:#0066cc;font-weight:bold;">int</span> step, <span style="color:#0066cc;font-weight:bold;">int</span>[] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(step == <span style="color:#098658;">0</span>) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[step] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[step];

        <span style="color:#0066cc;font-weight:bold;">int</span> energy1 = Math.Abs(heights[step] - heights[step-<span style="color:#098658;">1</span>]) + Solve(heights, step-<span style="color:#098658;">1</span>, dp);
        <span style="color:#0066cc;font-weight:bold;">int</span> energy2 = <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue;

        <span style="color:#0066cc;font-weight:bold;">if</span>(step &gt; <span style="color:#098658;">1</span>)
        {
            energy2 = Math.Abs(heights[step] - heights[step-<span style="color:#098658;">2</span>]) + Solve(heights, step-<span style="color:#098658;">2</span>, dp); 
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[step] = Math.Min(energy1, energy2);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.3.3. Frog Jump KDistances</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
A frog wants to climb a staircase with n steps. Given an integer array heights, where heights[i] contains the height of the ith step, and an integer k.

To jump from the ith step to the jth step, the frog requires abs(heights[i] - heights[j]) energy, where abs() denotes the absolute difference. The frog can jump from the ith step to any step in the range [i + 1, i + k], provided it exists.

Return the minimum amount of energy required by the frog to go from the 0th step to the (n-1)th step.

Examples:
Input: heights = [10, 5, 20, 0, 15], k = 2

Output: 15

Explanation:

0th step -&gt; 2nd step, cost = abs(10 - 20) = 10

2nd step -&gt; 4th step, cost = abs(20 - 15) = 5

Total cost = 10 + 5 = 15.

Input: heights = [15, 4, 1, 14, 15], k = 3

Output: 2

Explanation:

0th step -&gt; 3rd step, cost = abs(15 - 14) = 1

3rd step -&gt; 4th step, cost = abs(14 - 15) = 1

Total cost = 1 + 1 = 2.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> frogJump(<span style="color:#0066cc;font-weight:bold;">int</span>[] heights, <span style="color:#0066cc;font-weight:bold;">int</span> k) {
        <span style="color:#0066cc;font-weight:bold;">int</span> n = heights.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n];
        <span style="color:#008000;font-weight:bold;">Array</span>.Fill(dp, -<span style="color:#098658;">1</span>);

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(heights, k, n-<span style="color:#098658;">1</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] heights, <span style="color:#0066cc;font-weight:bold;">int</span> k, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span>[] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(i == <span style="color:#098658;">0</span>) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i];

        <span style="color:#0066cc;font-weight:bold;">int</span> res = <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue;
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> m=k; m&gt;<span style="color:#098658;">0</span>; m--)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(i-m &gt;= <span style="color:#098658;">0</span> )
            {
                res = Math.Min(res, Math.Abs(heights[i-m] - heights[i]) + Solve(heights, k, i-m, dp));
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i] = res;
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.3.4. House Robber</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
A robber is targeting to rob houses from a street. Each house has security measures that alert the police when two adjacent houses are robbed. The houses are arranged in a circular manner, thus the first and last houses are adjacent to each other.

Given an integer array money, where money[i] represents the amount of money that can be looted from the (i+1)th house. Return the maximum amount of money that the robber can loot without alerting the police.

Examples:
Input: money = [2, 1, 4, 9]

Output: 10

Explanation:

[2, 1, 4, 9] The underlined houses would give the maximum loot.

Note that we cannot loot the 1st and 4th houses together.

Input: money = [1, 5, 2, 1, 6]

Output: 11

Explanation:

[1, 5, 2, 1, 6] The underlined houses would give the maximum loot.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> HouseRobber(<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; money) {

        <span style="color:#0066cc;font-weight:bold;">if</span>(money.Count == <span style="color:#098658;">1</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> money[<span style="color:#098658;">0</span>];
            
        <span style="color:#0066cc;font-weight:bold;">int</span> n = money.Count;
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp1 = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n];
        <span style="color:#008000;font-weight:bold;">Array</span>.Fill(dp1, -<span style="color:#098658;">1</span>);
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp2 = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n];
        <span style="color:#008000;font-weight:bold;">Array</span>.Fill(dp2, -<span style="color:#098658;">1</span>);

        <span style="color:#0066cc;font-weight:bold;">return</span> Math.Max(Solve(money, n-<span style="color:#098658;">2</span>, <span style="color:#098658;">0</span>, dp1), Solve(money, n-<span style="color:#098658;">1</span>, <span style="color:#098658;">1</span>, dp2));
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; money, <span style="color:#0066cc;font-weight:bold;">int</span> end, <span style="color:#0066cc;font-weight:bold;">int</span> idx, <span style="color:#0066cc;font-weight:bold;">int</span>[] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(idx == end) <span style="color:#0066cc;font-weight:bold;">return</span> money[idx];

        <span style="color:#0066cc;font-weight:bold;">if</span>(idx &gt; end) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[idx] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[idx];

        <span style="color:#008000;">// Not Pick</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res2 = Solve(money, end, idx+<span style="color:#098658;">1</span>, dp);

        <span style="color:#008000;">// pick</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = money[idx] + Solve(money, end, idx+<span style="color:#098658;">2</span>, dp);
        
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[idx] = Math.Max(res1, res2);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.3.5. Max Sum Non Adjacent Elements</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an integer array nums of size n. Return the maximum sum possible using the elements of nums such that no two elements taken are adjacent in nums.

Examples:
Input: nums = [1, 2, 4]

Output: 5

Explanation:

[1, 2, 4], the underlined elements are taken to get the maximum sum.

Input: nums = [2, 1, 4, 9]

Output: 11

Explanation:

[2, 1, 4, 9], the underlined elements are taken to get the maximum sum.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> NonAdjacent(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[nums.Length];
        <span style="color:#008000;font-weight:bold;">Array</span>.Fill(dp, -<span style="color:#098658;">1</span>);

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(nums, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums, <span style="color:#0066cc;font-weight:bold;">int</span> idx, <span style="color:#0066cc;font-weight:bold;">int</span>[] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(idx &gt;= nums.Length) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[idx] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[idx];
        <span style="color:#008000;">// Pick </span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = nums[idx] + Solve(nums, idx+<span style="color:#098658;">2</span>, dp);

        <span style="color:#008000;">// not pick</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res2 = Solve(nums, idx+<span style="color:#098658;">1</span>, dp);

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[idx] = Math.Max(res1, res2);
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h3 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 2.4. DP_Grids</h3>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.4.1. Cherry Pick 2</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a n x m 2d integer array called matrix where matrix[i][j] represents the number of cherries you can pick up from the (i, j) cell.Given two robots that can collect cherries, one is located at the top-leftmost (0, 0) cell and the other at the top-rightmost (0, m-1) cell.

Return the maximum number of cherries that can be picked by the two robots in total, following these rules:

Robots that are standing on (i, j) cell can only move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1), if it exists in the matrix.

A robot will pick up all the cherries in a given cell when it passes through that cell.

If both robots come to the same cell at the same time, only one robot takes the cherries.

Both robots must reach the bottom row in matrix.

Examples:
Input: matrix = [[2, 1, 3], [4, 2, 5], [1, 6, 2], [7, 2, 8]]

Output: 37

Explanation:

Possible left robot path:-

Start at 0th cell (2) -&gt; down (4) -&gt; down-right (6) -&gt;down-left (7)

Possible right robot path:-

Start at 2nd cell (3) -&gt; down (5) -&gt; down (2) -&gt; down (8)

Input: matrix = [[1, 4, 4, 1], [1, 2, 2, 1], [5, 6, 10, 11], [8, 1, 1, 1]]

Output: 32

Explanation:

Possible left robot path:-

Start at 0th cell (1) -&gt; down-right (2) -&gt; down (6) -&gt;down-left (8)

Possible right robot path:-

Start at 3rd cell (1) -&gt; down-left (2) -&gt; down-right (11) -&gt; down (1)
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> CherryPickup(<span style="color:#0066cc;font-weight:bold;">int</span>[][] matrix)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = matrix.Length, n = matrix[<span style="color:#098658;">0</span>].Length;

        <span style="color:#0066cc;font-weight:bold;">int</span>[,,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m,n,n];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> k=<span style="color:#098658;">0</span>; k&lt;n; k++)
                {
                    dp[i,j,k] = -<span style="color:#098658;">1</span>;
                }
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(matrix, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, n-<span style="color:#098658;">1</span>, dp);

    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[][] matrix, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span> k, <span style="color:#0066cc;font-weight:bold;">int</span>[,,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(matrix[<span style="color:#098658;">0</span>].Length &lt;= j || j &lt; <span style="color:#098658;">0</span> || k &lt; <span style="color:#098658;">0</span> || matrix[<span style="color:#098658;">0</span>].Length &lt;= k) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#0066cc;font-weight:bold;">int</span>.MinValue;

        
        <span style="color:#0066cc;font-weight:bold;">if</span>(matrix.Length-<span style="color:#098658;">1</span> == i) 
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(j == k)
                <span style="color:#0066cc;font-weight:bold;">return</span> matrix[i][j];
            <span style="color:#0066cc;font-weight:bold;">else</span>
                <span style="color:#0066cc;font-weight:bold;">return</span> matrix[i][k] + matrix[i][j];
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j,k] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j,k];

        <span style="color:#0066cc;font-weight:bold;">int</span> maxVal = <span style="color:#0066cc;font-weight:bold;">int</span>.MinValue;
        <span style="color:#0066cc;font-weight:bold;">int</span> ans = <span style="color:#098658;">0</span>;

        <span style="color:#008000;">// Explore all the paths direction =&gt; 3 * 3 = 9 directions</span>
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> m =- <span style="color:#098658;">1</span>; m &lt;= <span style="color:#098658;">1</span>; m++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> n = -<span style="color:#098658;">1</span>; n &lt;= <span style="color:#098658;">1</span>; n++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(j == k)
                {
                    ans = matrix[i][j] + Solve(matrix, i+<span style="color:#098658;">1</span>, j+m, k+n, dp);
                }
                <span style="color:#0066cc;font-weight:bold;">else</span>
                {
                    ans = matrix[i][j] + matrix[i][k] + Solve(matrix, i+<span style="color:#098658;">1</span>, j+m, k+n, dp);
                }

                maxVal = Math.Max(ans, maxVal);
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j,k] = maxVal;
        
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.4.2. Grid Unique Paths</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two integers m and n, representing the number of rows and columns of a 2d array named matrix. Return the number of unique ways to go from the top-left cell (matrix[0][0]) to the bottom-right cell (matrix[m-1][n-1]).

Movement is allowed only in two directions from a cell: right and bottom.

Examples:
Input: m = 3, n = 2

Output: 3

Explanation:

There are 3 unique ways to go from the top left to the bottom right cell.

1) right -&gt; down -&gt; down

2) down -&gt; right -&gt; down

3) down -&gt; down -&gt; right

Input: m = 2, n = 4

Output: 4

Explanation:

There are 4 unique ways to go from the top left to the bottom right cell.

1) down -&gt; right -&gt; right -&gt; right

2) right -&gt; down -&gt; right -&gt; right

3) right -&gt; right -&gt; down -&gt; right

4) right -&gt; right -&gt; right -&gt; down
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> uniquePaths(<span style="color:#0066cc;font-weight:bold;">int</span> m, <span style="color:#0066cc;font-weight:bold;">int</span> n) {
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m,n];
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(m, n, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span> m, <span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(i &gt;= m || j &gt;= n) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(i == m-<span style="color:#098658;">1</span> &amp;&amp; j == n-<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">1</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j];

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] = Solve(m, n, i+<span style="color:#098658;">1</span>, j, dp) + Solve(m, n, i, j+<span style="color:#098658;">1</span>, dp);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.4.3. Minimum Falling Path Sum</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a 2d array called matrix consisting of integer values. Return the minimum path sum that can be obtained by starting at any cell in the first row and ending at any cell in the last row.



Movement is allowed only to the bottom, bottom-right, or bottom-left cell of the current cell.


Examples:
Input: matrix = [[1, 2, 10, 4], [100, 3, 2, 1], [1, 1, 20, 2], [1, 2, 2, 1]]

Output: 6

Explanation:

One optimal route can be:-

Start at 1st cell of 1st row -&gt; bottom-right -&gt; bottom -&gt; bottom-left.

Input: matrix = [[1, 4, 3, 1], [2, 3, -1, -1], [1, 1, -1, 8]]

Output: -1

Explanation:

One optimal route can be:-

Start at 4th cell of 1st row -&gt; bottom-left -&gt; bottom.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> MinFallingPathSum(<span style="color:#0066cc;font-weight:bold;">int</span>[][] matrix) {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = matrix.Length, n = matrix[<span style="color:#098658;">0</span>].Length;

        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m,n];

        <span style="color:#0066cc;font-weight:bold;">int</span> res = <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue;

        <span style="color:#008000;">// There is no need of doing Reset DP at each step. As it&#x27;s not gonna disturb other solutions</span>
        ResetDP(dp, m, n);

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
        {         
            res = Math.Min(res, Solve(matrix, <span style="color:#098658;">0</span>, j, dp));
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[][] matrix, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#008000;">// Here return int.MaxValue it&#x27;s output should be discarded. </span>
        <span style="color:#008000;">// Since we are looking for minimum so, we will assign max value to discard it</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(i &gt;= matrix.Length || j &gt;= matrix[<span style="color:#098658;">0</span>].Length || j &lt; <span style="color:#098658;">0</span>) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue;

        <span style="color:#0066cc;font-weight:bold;">if</span>(matrix.Length-<span style="color:#098658;">1</span> == i) <span style="color:#0066cc;font-weight:bold;">return</span> matrix[i][j];

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j];

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] = matrix[i][j] + Math.Min(Solve(matrix, i+<span style="color:#098658;">1</span>,j, dp), Math.Min(Solve(matrix, i+<span style="color:#098658;">1</span>, j+<span style="color:#098658;">1</span>, dp), Solve(matrix, i+<span style="color:#098658;">1</span>, j-<span style="color:#098658;">1</span>, dp)));
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> ResetDP(<span style="color:#0066cc;font-weight:bold;">int</span>[,] dp, <span style="color:#0066cc;font-weight:bold;">int</span> m, <span style="color:#0066cc;font-weight:bold;">int</span> n)
    {
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.4.4. Triangle Falling Path</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a 2d integer array named triangle with n rows. Its first row has 1 element and each succeeding row has one more element in it than the row above it.

Return the minimum falling path sum from the first row to the last.

Movement is allowed only to the bottom or bottom-right cell from the current cell.


Examples:
Input: triangle = [[1], [1, 2], [1, 2, 4]]

Output: 3

Explanation:

One possible route can be:

Start at 1st row -&gt; bottom -&gt; bottom.

Input: triangle = [[1], [4, 7], [4,10, 50], [-50, 5, 6, -100]]

Output: -42

Explanation:

One possible route can be:

Start at 1st row -&gt; bottom-right -&gt; bottom-right -&gt; bottom-right
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> MinTriangleSum(<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; triangle)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = triangle.Count, n = triangle.Count;

        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m,n];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(triangle, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dp); 
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; triangle, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(triangle.Count &lt;= i || j &gt; i) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue;

        <span style="color:#0066cc;font-weight:bold;">if</span>(triangle.Count-<span style="color:#098658;">1</span> == i) <span style="color:#0066cc;font-weight:bold;">return</span> triangle[i][j];

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j];

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] = triangle[i][j] + Math.Min(Solve(triangle, i+<span style="color:#098658;">1</span>, j, dp), Solve(triangle, i+<span style="color:#098658;">1</span>, j+<span style="color:#098658;">1</span>, dp));
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.4.5. Unique Paths With Obstacles</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an m x n 2d array named matrix, where each cell is either 0 or 1. Return the number of unique ways to go from the top-left cell (matrix[0][0]) to the bottom-right cell (matrix[m-1][n-1]). A cell is blocked if its value is 1, and no path is possible through that cell.



Movement is allowed in only two directions from a cell - right and bottom.


Examples:
Input: matrix = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]

Output: 2

Explanation:

The two possible paths are:

1) down -&gt; down-&gt; right -&gt; right

2) right -&gt; right -&gt; down -&gt; down

Input: matrix = [[0, 0, 0], [0, 0, 1], [0, 1, 0]]

Output: 0

Explanation:

There is no way to reach the bottom-right cell.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> UniquePathsWithObstacles(<span style="color:#0066cc;font-weight:bold;">int</span>[][] matrix) {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = matrix.Length, n = matrix[<span style="color:#098658;">0</span>].Length;

        <span style="color:#008000;">// Junt ensure that whether destination cell is rechable or not</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(matrix[m-<span style="color:#098658;">1</span>][n-<span style="color:#098658;">1</span>] == <span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m,n];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(matrix, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[][] matrix, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(matrix.Length &lt;= i || matrix[<span style="color:#098658;">0</span>].Length &lt;= j) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(matrix.Length-<span style="color:#098658;">1</span> == i &amp;&amp; matrix[<span style="color:#098658;">0</span>].Length-<span style="color:#098658;">1</span> == j) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">1</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(matrix[i][j] == <span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j];

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] = Solve(matrix, i+<span style="color:#098658;">1</span>, j, dp) + Solve(matrix, i, j+<span style="color:#098658;">1</span>, dp);
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h3 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 2.5. LCS</h3>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.1. Distinct Subsequences_Bottom Up</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two strings s and t, return the number of distinct subsequences of s that equal t.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not.

The task is to count how many different ways we can form t from s by deleting some (or no) characters from s. Return the result modulo 109+7.

Examples:
Input: s = &quot;axbxax&quot;, t = &quot;axa&quot;

Output: 2

Explanation: In the string &quot;axbxax&quot;, there are two distinct subsequences &quot;axa&quot;:

(a)(x)bx(a)x

(a)xb(x)(a)x

Input: s = &quot;babgbag&quot;, t = &quot;bag&quot;
Output: 5

Explanation: In the string &quot;babgbag&quot;, there are five distinct subsequences &quot;bag&quot;:

(ba)(b)(ga)(g)

(ba)(bg)(ag)

(bab)(ga)(g)

(bab)(g)(ag)

(babg)(a)(g)
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">const</span> <span style="color:#0066cc;font-weight:bold;">int</span> MOD = <span style="color:#098658;">1000000007</span>;
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> DistinctSubsequences(<span style="color:#0066cc;font-weight:bold;">string</span> s, <span style="color:#0066cc;font-weight:bold;">string</span> t)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = s.Length, n = t.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m+<span style="color:#098658;">1</span>, n+<span style="color:#098658;">1</span>];

        <span style="color:#008000;">// Initialize Base case</span>
        <span style="color:#008000;">// if &quot;t&quot; is empty then there will be only one subsequence length i.e empty</span>
        <span style="color:#008000;">// if &quot;s&quot; is empty it means there is zero subsequence possible</span>
        <span style="color:#008000;">// i.e if len(s) == 0 then dp[0,j] = 0</span>
        <span style="color:#008000;">// if len(t) == 0 then dp[i,0] = 1. considering empty case</span>

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;=m; i++)
        {
            dp[i,<span style="color:#098658;">0</span>] = <span style="color:#098658;">1</span>;
        }

        <span style="color:#008000;">// No need of this initialization as by default its zero only</span>
        <span style="color:#008000;">// Need to start with 1 as if both are of zero length then empty should be common to both so, it won&#x27;t be zero  but one</span>
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">1</span>; j&lt;=n; j++)
        {
            dp[<span style="color:#098658;">0</span>,j] = <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;=m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">1</span>; j&lt;=n; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(s[i-<span style="color:#098658;">1</span>] == t[j-<span style="color:#098658;">1</span>])
                {
                    dp[i,j] = (dp[i-<span style="color:#098658;">1</span>, j-<span style="color:#098658;">1</span>] % MOD + dp[i-<span style="color:#098658;">1</span>, j] % MOD) % MOD;
                }
                <span style="color:#0066cc;font-weight:bold;">else</span>
                {
                    dp[i,j] = dp[i-<span style="color:#098658;">1</span>, j] % MOD;
                }
            }
        } 

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[m,n];
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.2. Distinct Subsequences_Recrusive</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two strings s and t, return the number of distinct subsequences of s that equal t.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not.

The task is to count how many different ways we can form t from s by deleting some (or no) characters from s. Return the result modulo 109+7.

Examples:
Input: s = &quot;axbxax&quot;, t = &quot;axa&quot;

Output: 2

Explanation: In the string &quot;axbxax&quot;, there are two distinct subsequences &quot;axa&quot;:

(a)(x)bx(a)x

(a)xb(x)(a)x

Input: s = &quot;babgbag&quot;, t = &quot;bag&quot;

Output: 5

Explanation: In the string &quot;babgbag&quot;, there are five distinct subsequences &quot;bag&quot;:

(ba)(b)(ga)(g)

(ba)(bg)(ag)

(bab)(ga)(g)

(bab)(g)(ag)

(babg)(a)(g)
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">const</span> <span style="color:#0066cc;font-weight:bold;">int</span> MOD = <span style="color:#098658;">1000000007</span>;
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> DistinctSubsequences(<span style="color:#0066cc;font-weight:bold;">string</span> s, <span style="color:#0066cc;font-weight:bold;">string</span> t)
    {
      <span style="color:#0066cc;font-weight:bold;">int</span> m = s.Length, n = t.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m, n];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;m; i++)
        {
          <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
          {
            dp[i,j] = -<span style="color:#098658;">1</span>;
          }
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(s, t, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">string</span> s, <span style="color:#0066cc;font-weight:bold;">string</span> t, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
       <span style="color:#0066cc;font-weight:bold;">if</span>(t.Length == j)
       {
          <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">1</span>;
       }

       <span style="color:#0066cc;font-weight:bold;">if</span>(s.Length == i)
       {
          <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
       }

       <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j];

        <span style="color:#0066cc;font-weight:bold;">if</span>(s[i] == t[j])
        {
          <span style="color:#008000;">// Need to add both the condition pick and not pick as we need to find all the subsequences</span>
          <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] = (Solve(s, t, i+<span style="color:#098658;">1</span>, j+<span style="color:#098658;">1</span>, dp) % MOD + Solve(s, t, i+<span style="color:#098658;">1</span>, j, dp) % MOD) % MOD;
        }
        <span style="color:#0066cc;font-weight:bold;">else</span>
        {
          <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] = Solve(s, t, i+<span style="color:#098658;">1</span>, j, dp) % MOD;
        }
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.3. Edit Distance_Bottom Up</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two strings start and target, you need to determine the minimum number of operations required to convert the string start into the string target. The operations you can use are:

Insert a character: Add any single character at any position in the string.

Delete a character: Remove any single character from the string.

Replace a character: Change any single character in the string to another character.

The goal is to transform start into target using the fewest number of these operations.

Examples:
Input: start = &quot;planet&quot;, target = &quot;plan&quot;

Output: 2

Explanation: 

To transform &quot;planet&quot; into &quot;plan&quot;, the following operations are required:

1. Delete the character &#x27;e&#x27;: &quot;planet&quot; -&gt; &quot;plan&quot;

2. Delete the character &#x27;t&#x27;: &quot;plan&quot; -&gt; &quot;plan&quot;

Thus, a total of 2 operations are needed.

Input: start = &quot;abcdefg&quot;, target = &quot;azced&quot;

Output: 4

Explanation: 

To transform &quot;abcdefg&quot; into &quot;azced&quot;, the following operations are required:

1. Replace &#x27;b&#x27; with &#x27;z&#x27;: &quot;abcdefg&quot; -&gt; &quot;azcdefg&quot;

2. Delete &#x27;d&#x27;: &quot;azcdefg&quot; -&gt; &quot;azcefg&quot;

3. Delete &#x27;f&#x27;: &quot;azcefg&quot; -&gt; &quot;azceg&quot;

4. Replace &#x27;g&#x27; with &#x27;d&#x27;: &quot;azceg&quot; -&gt; &quot;azced&quot;

Thus, a total of 4 operations are needed.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> editDistance(<span style="color:#0066cc;font-weight:bold;">string</span> start, <span style="color:#0066cc;font-weight:bold;">string</span> target)
    {
        <span style="color:#008000;">// Wrong Approach: Find LCS count</span>
        <span style="color:#008000;">// Now apply formula : ans = (start.Length - lcs) - (target.Length - lcs) XXXXX (Noooo, it won&#x27;t work)</span>

        <span style="color:#008000;">// Correct Approach</span>
        <span style="color:#008000;">// Consider all the operations and then take minimum</span>
        <span style="color:#008000;">// No need to do the actual changes like insert/update/delete</span>
        <span style="color:#008000;">// But just simulate the scenarios and update the index values</span>

        <span style="color:#0066cc;font-weight:bold;">int</span> m = start.Length, n = target.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m+<span style="color:#098658;">1</span>, n+<span style="color:#098658;">1</span>];

        <span style="color:#008000;">// Initialize as if target.Length == 0 then need to remove all chars in start. hence dp[i,0] = i</span>
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;=m; i++) {
            dp[i,<span style="color:#098658;">0</span>] = i;
        }

        <span style="color:#008000;">// Initialize as if start.Length == 0 then need to remove all chars in target. hence dp[0,i] = i</span>
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;=n; i++) {
            dp[<span style="color:#098658;">0</span>,i] = i;
        }

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;=m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">1</span>; j&lt;=n; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(start[i-<span style="color:#098658;">1</span>] == target[j-<span style="color:#098658;">1</span>])
                {
                    dp[i,j] = dp[i-<span style="color:#098658;">1</span>, j-<span style="color:#098658;">1</span>];
                }
                <span style="color:#0066cc;font-weight:bold;">else</span>
                {
                    dp[i,j] = <span style="color:#098658;">1</span> + Math.Min(dp[i,j-<span style="color:#098658;">1</span>], Math.Min(dp[i-<span style="color:#098658;">1</span>, j], dp[i-<span style="color:#098658;">1</span>, j-<span style="color:#098658;">1</span>]));
                } 
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[m,n];
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.4. LCSubsequence</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two strings str1 and str2, find the length of their longest common subsequence.

A subsequence is a sequence that appears in the same relative order but not necessarily contiguous and a common subsequence of two strings is a subsequence that is common to both strings.

Examples:
Input: str1 = &quot;bdefg&quot;, str2 = &quot;bfg&quot;

Output: 3

Explanation: The longest common subsequence is &quot;bfg&quot;, which has a length of 3.

Input: str1 = &quot;mnop&quot;, str2 = &quot;mnq&quot;

Output: 2

Explanation: The longest common subsequence is &quot;mn&quot;, which has a length of 2.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> Lcs(<span style="color:#0066cc;font-weight:bold;">string</span> str1, <span style="color:#0066cc;font-weight:bold;">string</span> str2)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[str1.Length, str2.Length];
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;str1.Length; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;str2.Length; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> LCS(str1, str2, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> LCS(<span style="color:#0066cc;font-weight:bold;">string</span> s1, <span style="color:#0066cc;font-weight:bold;">string</span> s2, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(s1.Length == i || s2.Length == j)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j] != -<span style="color:#098658;">1</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j];

        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = <span style="color:#098658;">0</span>, res2 = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">if</span>(s1[i] == s2[j])
        {
            res1 = <span style="color:#098658;">1</span> + LCS(s1, s2, i+<span style="color:#098658;">1</span>, j+<span style="color:#098658;">1</span>, dp);
        }
        <span style="color:#0066cc;font-weight:bold;">else</span>
        {
            res2 = Math.Max(LCS(s1, s2, i+<span style="color:#098658;">1</span>, j, dp), LCS(s1, s2, i, j+<span style="color:#098658;">1</span>, dp));
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] = Math.Max(res1, res2);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.5. LCSubstring_Bottom UP</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two strings str1 and str2, find the length of their longest common substring.

A substring is a contiguous sequence of characters within a string.

Examples:
Input: str1 = &quot;abcde&quot;, str2 = &quot;abfce&quot;

Output: 2

Explanation: The longest common substring is &quot;ab&quot;, which has a length of 2.

Input: str1 = &quot;abcdxyz&quot;, str2 = &quot;xyzabcd&quot;

Output: 4

Explanation: The longest common substring is &quot;abcd&quot;, which has a length of 4.

Input: str1 = &quot;abcdef&quot;, str2 = &quot;ghijkl&quot;

Output:
0
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> longestCommonSubstr(<span style="color:#0066cc;font-weight:bold;">string</span> str1, <span style="color:#0066cc;font-weight:bold;">string</span> str2)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = str1.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span> n = str2.Length;

        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span> [m+<span style="color:#098658;">1</span>,n+<span style="color:#098658;">1</span>];
        <span style="color:#0066cc;font-weight:bold;">int</span> maxLength = <span style="color:#098658;">0</span>;

        <span style="color:#008000;">// Here in indexes we are considering the length of substring </span>
        <span style="color:#008000;">// That&#x27;s why we are taking the startin index for i and j as &quot;1&quot;</span>
        <span style="color:#008000;">// But while comparing the string taking &quot;i-1 and j-1&quot; as in string it will work on Array based index</span>
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;=m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">1</span>; j&lt;=n; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(str1[i-<span style="color:#098658;">1</span>] == str2[j-<span style="color:#098658;">1</span>])
                {
                    dp[i,j] = <span style="color:#098658;">1</span> + dp[i-<span style="color:#098658;">1</span>,j-<span style="color:#098658;">1</span>];
                }
                <span style="color:#0066cc;font-weight:bold;">else</span>
                {
                    dp[i,j] = <span style="color:#098658;">0</span>;
                }

                maxLength = Math.Max(maxLength, dp[i,j]);
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> maxLength;
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.6. LCSubstring_Recursive</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two strings str1 and str2, find the length of their longest common substring.

A substring is a contiguous sequence of characters within a string.

Examples:
Input: str1 = &quot;abcde&quot;, str2 = &quot;abfce&quot;

Output: 2

Explanation: The longest common substring is &quot;ab&quot;, which has a length of 2.

Input: str1 = &quot;abcdxyz&quot;, str2 = &quot;xyzabcd&quot;

Output: 4

Explanation: The longest common substring is &quot;abcd&quot;, which has a length of 4.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> longestCommonSubstr(<span style="color:#0066cc;font-weight:bold;">string</span> str1, <span style="color:#0066cc;font-weight:bold;">string</span> str2)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[,,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[str1.Length+<span style="color:#098658;">1</span>, str2.Length+<span style="color:#098658;">1</span>, Math.Min(str1.Length, str2.Length)+<span style="color:#098658;">1</span>];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;=str1.Length; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;=str2.Length; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> k=<span style="color:#098658;">0</span>; k&lt;= Math.Min(str1.Length, str2.Length); k++)
                {
                    dp[i,j,k] = -<span style="color:#098658;">1</span>;
                }
            }
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(str1, str2, str1.Length-<span style="color:#098658;">1</span>, str2.Length-<span style="color:#098658;">1</span>, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">string</span> s1, <span style="color:#0066cc;font-weight:bold;">string</span> s2, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span> count, <span style="color:#0066cc;font-weight:bold;">int</span>[,,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(i &lt; <span style="color:#098658;">0</span> || j &lt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> count;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j,count] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j,count];

        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">if</span>(s1[i] == s2[j])
        {
            <span style="color:#008000;">// Since we need to reset the sum if s[i] != s[j] so,</span>
            <span style="color:#008000;">// we are passing the count and incrementing in Param as</span>
            <span style="color:#008000;">// if I would have done it like &quot;res1 = 1 + Solve(s1, s2, i-1, j-1)&quot; then,</span>
            <span style="color:#008000;">// It will try to find the other solution there onwards with existing length</span>
            <span style="color:#008000;">// However it would work for Subsequence but not for substring</span>
            <span style="color:#008000;">// As for Substring we always need to reset the length if chars are not same</span>
            res1 = Solve(s1, s2, i-<span style="color:#098658;">1</span>, j-<span style="color:#098658;">1</span>, count+<span style="color:#098658;">1</span>, dp); 
        }

        <span style="color:#0066cc;font-weight:bold;">int</span> res2 = Math.Max(Solve(s1, s2, i, j-<span style="color:#098658;">1</span>, <span style="color:#098658;">0</span>, dp), Solve(s1, s2, i-<span style="color:#098658;">1</span>, j, <span style="color:#098658;">0</span>, dp));
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j,count] = Math.Max(count, Math.Max(res1, res2));
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.7. Longest Palindrome</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a string, Find the longest palindromic subsequence length in given string.

A palindrome is a sequence that reads the same backwards as forward.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.


Examples:
Input: s = &quot;eeeme&quot;

Output: 4

Explanation: The longest palindromic subsequence is &quot;eeee&quot;, which has a length of 4.

Input: s = &quot;annb&quot;

Output: 2

Explanation: The longest palindromic subsequence is &quot;nn&quot;, which has a length of 2.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> LongestPalinSubseq(<span style="color:#0066cc;font-weight:bold;">string</span> s) {
      
      <span style="color:#008000;">// We just need to reverse the string and then apply LCS </span>
      <span style="color:#008000;">// It will give longest Palindrome as after reversal it should be same only</span>
      
      char[] rev_arr = s.ToCharArray();
      <span style="color:#008000;font-weight:bold;">Array</span>.Reverse(rev_arr);
      <span style="color:#0066cc;font-weight:bold;">string</span> rev_s = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">string</span>(rev_arr);

      <span style="color:#0066cc;font-weight:bold;">return</span> LCS(s, rev_s);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> LCS(<span style="color:#0066cc;font-weight:bold;">string</span> s1, <span style="color:#0066cc;font-weight:bold;">string</span> s2)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = s1.Length, n = s2.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m+<span style="color:#098658;">1</span>, n+<span style="color:#098658;">1</span>];

        <span style="color:#0066cc;font-weight:bold;">int</span> maxLength = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;=m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">1</span>; j&lt;=n; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(s1[i-<span style="color:#098658;">1</span>] == s2[j-<span style="color:#098658;">1</span>])
                {
                    dp[i,j] = <span style="color:#098658;">1</span> + dp[i-<span style="color:#098658;">1</span>, j-<span style="color:#098658;">1</span>];
                }
                <span style="color:#0066cc;font-weight:bold;">else</span>
                {
                    dp[i,j] = Math.Max(dp[i, j-<span style="color:#098658;">1</span>], dp[i-<span style="color:#098658;">1</span>, j]);
                }

                maxLength = Math.Max(dp[i,j], maxLength);
            }
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> maxLength;
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.8. Min Insert Delete To Convert</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two strings str1 and str2, find the minimum number of insertions and deletions in string str1 required to transform str1 into str2.

Insertion and deletion of characters can take place at any position in the string.

Examples:
Input: str1 = &quot;kitten&quot;, str2 = &quot;sitting&quot;

Output: 5

Explanation: To transform &quot;kitten&quot; to &quot;sitting&quot;, delete &quot;k&quot; and insert &quot;s&quot; to get &quot;sitten&quot;, then insert &quot;i&quot; to get &quot;sittin&quot;, and insert &quot;g&quot; at the end to get &quot;sitting&quot;.

Input: str1 = &quot;flaw&quot;, str2 = &quot;lawn&quot;

Output: 2

Explanation: To transform &quot;flaw&quot; to &quot;lawn&quot;, delete &quot;f&quot; and insert &quot;n&quot; at the end. Hence minimum number of operations required is 2&quot;.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> minOperations(<span style="color:#0066cc;font-weight:bold;">string</span> str1, <span style="color:#0066cc;font-weight:bold;">string</span> str2)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> lcs = LCS(str1, str2);

        <span style="color:#008000;">// if we take the difference of lcs with str1.Length and str2.Length and Add them</span>
        <span style="color:#008000;">// It will give total insert/delete count as these are extra elements other than LCS</span>
        <span style="color:#008000;">// So, To convert we need to do all these insert and delete operations</span>
        <span style="color:#0066cc;font-weight:bold;">return</span> str1.Length - lcs + str2.Length - lcs;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> LCS(<span style="color:#0066cc;font-weight:bold;">string</span> str1, <span style="color:#0066cc;font-weight:bold;">string</span> str2)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = str1.Length, n = str2.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m+<span style="color:#098658;">1</span>, n+<span style="color:#098658;">1</span>];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;=m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">1</span>; j&lt;=n; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(str1[i-<span style="color:#098658;">1</span>] == str2[j-<span style="color:#098658;">1</span>])
                {
                    dp[i,j] = <span style="color:#098658;">1</span> + dp[i-<span style="color:#098658;">1</span>, j-<span style="color:#098658;">1</span>];
                }
                <span style="color:#0066cc;font-weight:bold;">else</span>
                {
                    dp[i,j] = Math.Max(dp[i,j-<span style="color:#098658;">1</span>], dp[i-<span style="color:#098658;">1</span>, j]);
                }
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[m,n];
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.9. Min Insertion To Make Palindrome</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a string s, find the minimum number of insertions needed to make it a palindrome. A palindrome is a sequence that reads the same backward as forward. You can insert characters at any position in the string.

Examples:
Input: s = &quot;abcaa&quot;

Output: 2

Explanation: Insert 2 characters &quot;c&quot;, and &quot;b&quot; to make &quot;abcacba&quot;, which is a palindrome.

Input: s = &quot;ba&quot;

Output: 1

Explanation: Insert &quot;a&quot; at the beginning to make &quot;aba&quot;, which is a palindrome.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{

    <span style="color:#008000;">// If we Subtract the length of longest common subsequence from </span>
    <span style="color:#008000;">// Actual string length then we will get the minimum count of insertions</span>
    <span style="color:#008000;">// Intution : Keep the Exixting palindromic Sequence intact and then for existing which are not part of </span>
    <span style="color:#008000;">// Palindromic subsequence then these needs to be added at other places to make the complete string Palindrome</span>

    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> minInsertion(<span style="color:#0066cc;font-weight:bold;">string</span> s)
    {
        char[] rev_arr = s.ToCharArray();
        <span style="color:#008000;font-weight:bold;">Array</span>.Reverse(rev_arr);
        <span style="color:#0066cc;font-weight:bold;">string</span> s_rev = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">string</span>(rev_arr);

        <span style="color:#0066cc;font-weight:bold;">return</span> s.Length - LCS(s, s_rev);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> LCS(<span style="color:#0066cc;font-weight:bold;">string</span> s1, <span style="color:#0066cc;font-weight:bold;">string</span> s2)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = s1.Length;

        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m+<span style="color:#098658;">1</span>, m+<span style="color:#098658;">1</span>];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;=m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">1</span>; j&lt;=m; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(s1[i-<span style="color:#098658;">1</span>] == s2[j-<span style="color:#098658;">1</span>])
                {
                    dp[i,j] = <span style="color:#098658;">1</span> + dp[i-<span style="color:#098658;">1</span>, j-<span style="color:#098658;">1</span>];
                }
                <span style="color:#0066cc;font-weight:bold;">else</span>
                {
                    dp[i,j] = Math.Max(dp[i-<span style="color:#098658;">1</span>, j], dp[i, j-<span style="color:#098658;">1</span>]);
                }
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[m,m];
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.5.10. Wild Card Matching</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a string str and a pattern pat, implement a pattern matching function that supports the following special characters:

&#x27;?&#x27; Matches any single character.

&#x27;*&#x27; Matches any sequence of characters (including the empty sequence).

The pattern must match the entire string.

Examples:
Input: str = &quot;xaylmz&quot;, pat = &quot;x?y*z&quot;

Output: true

Explanation: 

The pattern &quot;x?y*z&quot; matches the string &quot;xaylmz&quot;:

- &#x27;?&#x27; matches &#x27;a&#x27;

- &#x27;*&#x27; matches &quot;lm&quot;

- &#x27;z&#x27; matches &#x27;z&#x27;

Input: str = &quot;xyza&quot;, pat = &quot;x*z&quot;

Output: false

Explanation: 

The pattern &quot;x*z&quot; does not match the string &quot;xyza&quot; because there is an extra &#x27;a&#x27; at the end of the string that is not matched by the pattern.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">bool</span> WildCard(<span style="color:#0066cc;font-weight:bold;">string</span> str, <span style="color:#0066cc;font-weight:bold;">string</span> pat)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> m = str.Length, n = pat.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[m,n];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;m; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(str, pat, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">bool</span> Solve(<span style="color:#0066cc;font-weight:bold;">string</span> s, <span style="color:#0066cc;font-weight:bold;">string</span> p, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#008000;">// if both pattern and string reached till end or exhausted</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(s.Length == i &amp;&amp; p.Length == j)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> true;
        }

        <span style="color:#008000;">// if pattern exhausted but not the string</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(p.Length == j)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> false;
        }

        <span style="color:#008000;">// if string exhausted but not the pattern</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(s.Length == i)
        {
            <span style="color:#008000;">// just validate if in pattern there is * in remianing pattern</span>
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> k=j; k&lt;p.Length; k++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(p[k] != &#x27;*&#x27;)
                    <span style="color:#0066cc;font-weight:bold;">return</span> false;
            }

            <span style="color:#0066cc;font-weight:bold;">return</span> true;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] == <span style="color:#098658;">1</span>;

        <span style="color:#0066cc;font-weight:bold;">bool</span> res = false;

        <span style="color:#008000;">// If there is a match of chars</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(s[i] == p[j] || p[j] == &#x27;?&#x27;)
        {
            dp[i,j] = Solve(s, p, i+<span style="color:#098658;">1</span>, j+<span style="color:#098658;">1</span>, dp) ? <span style="color:#098658;">1</span> : <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span>(p[j] == &#x27;*&#x27;)
        {
            <span style="color:#008000;">// considering that in pattern there is * but it could be skipped </span>
            <span style="color:#008000;">// as in string it might not be required to match with any char</span>
            dp[i,j] = (Solve(s, p, i+<span style="color:#098658;">1</span>, j, dp) || Solve(s, p, i, j+<span style="color:#098658;">1</span>, dp)) ? <span style="color:#098658;">1</span> : <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] == <span style="color:#098658;">1</span>;
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h3 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 2.6. LIS</h3>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.6.1. Count Total LIS</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an integer array nums, find the number of Longest Increasing Subsequences (LIS) in the array.

Examples:
Input: nums = [1, 3, 5, 4, 7]

Output: 2

Explanation: There are two LIS of length 4:

[1, 3, 4, 7]

[1, 3, 5, 7].

Input: nums = [2, 2, 2, 2, 2]

Output: 5

Explanation: All elements are the same, so every single element can form an LIS of length 1. There are 5 such subsequences.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> NumberOfLIS(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[nums.Length];

        <span style="color:#008000;">// Need one count array to store the possible ways to create the same subsequences Length</span>
        <span style="color:#0066cc;font-weight:bold;">int</span>[] count = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[nums.Length];

        <span style="color:#0066cc;font-weight:bold;">int</span> maxLength = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;nums.Length; i++)
        {
            dp[i] = <span style="color:#098658;">1</span>;
            count[i] = <span style="color:#098658;">1</span>;

            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;i; j++)
            {
                <span style="color:#008000;">// if nums[i] &gt; nums[j] then we Need to consider the scenarios </span>
                <span style="color:#008000;">// when current subsequnce length is equal or less than previous</span>
                
                <span style="color:#0066cc;font-weight:bold;">if</span>(nums[i] &gt; nums[j])
                {
                    <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i] &lt; <span style="color:#098658;">1</span> + dp[j])
                    {
                        dp[i] = <span style="color:#098658;">1</span> + dp[j];
                        <span style="color:#008000;">// Count will be just updated if it reaches for the first time with prev Index count</span>
                        count[i] = count[j];
                    }
                    <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i] == <span style="color:#098658;">1</span> + dp[j])
                    {
                        <span style="color:#008000;">// Going further we need to add the count for previous index </span>
                        count[i] += count[j];
                    }
                }
                
            }

            <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i] &gt; maxLength)
                maxLength = dp[i];
        }

        <span style="color:#0066cc;font-weight:bold;">int</span> subsetCount = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;dp.Length; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i] == maxLength)
            {
                subsetCount += count[i];
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> subsetCount;
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.6.2. LIS+Binary Search</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an integer array nums, return the length of the longest strictly increasing subsequence.

A subsequence is a sequence derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3, 6, 2, 7] is a subsequence of [0, 3, 1, 6, 2, 2, 7].

The task is to find the length of the longest subsequence in which every element is greater than the previous one.

Examples:
Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]

Output: 4

Explanation: The longest increasing subsequence is [2, 3, 7, 101], and its length is 4.

Input: nums = [0, 1, 0, 3, 2, 3]

Output: 4

Explanation: The longest increasing subsequence is [0, 1, 2, 3], and its length is 4

Input: nums = [7, 7, 7, 7, 7, 7, 7]

Output:
1
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> LIS(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums)
    {
        <span style="color:#008000;">// This list gets updated whenever subsequence count gets updated</span>
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; tails = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
        tails.Add(nums[<span style="color:#098658;">0</span>]);

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;nums.Length; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(nums[i] &gt; tails.Last())
            {
                tails.Add(nums[i]);
            }
            <span style="color:#0066cc;font-weight:bold;">else</span>
            {
                <span style="color:#0066cc;font-weight:bold;">int</span> idx = tails.BinarySearch(nums[i]);
                <span style="color:#0066cc;font-weight:bold;">if</span>(idx &lt; <span style="color:#098658;">0</span>)
                {
                    tails[~idx] = nums[i]; <span style="color:#008000;">// It gives immediate next greater number</span>
                }
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> tails.Count;
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.6.3. LIS_Print_Lexicographically</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array of n integers arr, return the Longest Increasing Subsequence (LIS) that is Index-wise Lexicographically Smallest.

The Longest Increasing Subsequence (LIS) is the longest subsequence where all elements are in strictly increasing order.

A subsequence A1 is Index-wise Lexicographically Smaller than another subsequence A2 if, at the first position where A1 and A2 differ, the element in A1 appears earlier in the array arr than corresponding element in S2.

Your task is to return the LIS that is Index-wise Lexicographically Smallest from the given array.

Examples:
Input: arr = [10, 22, 9, 33, 21, 50, 41, 60, 80]

Output: [10, 22, 33, 50, 60, 80]

Explanation: The LIS is [10, 22, 33, 50, 60, 80] and it is the lexicographically smallest.

Input: arr = [1, 3, 2, 4, 6, 5]

Output: [1, 3, 4, 6]

Explanation: Possible LIS sequences are [1, 3, 4, 6] and [1, 2, 4, 6]. Since [1, 3, 4, 6] is Index-wise Lexicographically Smaller, it is the result.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; LongestIncreasingSubsequence(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[arr.Length];
        <span style="color:#0066cc;font-weight:bold;">int</span>[] backTrack = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[arr.Length];

        <span style="color:#008000;">/* 
        Not required as it can be done in below loop only
        Array.Fill(dp, 1);
        for(int i=0;i&lt;arr.Length; i++)
        {
                backTrack[i] = i;
        }
       */</span>

        <span style="color:#0066cc;font-weight:bold;">int</span> maxIndex = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> i = <span style="color:#098658;">0</span>; i &lt; arr.Length; i++)
        {
            <span style="color:#008000;">// Initializing the dp array and backtrack Array in this loop only </span>
            dp[i] = <span style="color:#098658;">1</span>;
            backTrack[i] = i;

            <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> j = <span style="color:#098658;">0</span>; j &lt;= i; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span> (arr[i] &gt; arr[j] &amp;&amp; dp[j] + <span style="color:#098658;">1</span> &gt; dp[i])
                {
                    dp[i] = <span style="color:#098658;">1</span> + dp[j];
                    backTrack[i] = j;
                }
            }

            <span style="color:#008000;">// Updating the index having Max Subsequence Length</span>
            <span style="color:#0066cc;font-weight:bold;">if</span> (dp[i] &gt; dp[maxIndex])
            {
                maxIndex = i;
            }
        }

        <span style="color:#008000;">/* Not required as already done in the above loop only
            int maxIndex = 0;
            for(int i=1; i&lt;arr.Length; i++)
            {
                if(dp[i] &gt; dp[maxIndex])
                    maxIndex = i;
            }
        */</span>

        <span style="color:#008000;">// Constructing the subsequence using backtracking</span>
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; subsequence = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        <span style="color:#0066cc;font-weight:bold;">while</span> (maxIndex != backTrack[maxIndex])
        {
            subsequence.Add(arr[maxIndex]);
            maxIndex = backTrack[maxIndex];
        }

        subsequence.Add(arr[maxIndex]);

        subsequence.Reverse();
        <span style="color:#0066cc;font-weight:bold;">return</span> subsequence;
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.6.4. Longest Bitionic Sequence</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array arr of n integers, the task is to find the length of the longest bitonic sequence. A sequence is considered bitonic if it first increases, then decreases. The sequence does not have to be contiguous.

Examples:
Input: arr = [5, 1, 4, 2, 3, 6, 8, 7]

Output: 6

Explanation: The longest bitonic sequence is [1, 2, 3, 6, 8, 7] with length 6.

Input: arr = [10, 20, 30, 40, 50, 40, 30, 20]

Output: 8

Explanation: The entire array is bitonic, increasing up to 50 and then decreasing.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> LongestBitonicSequence(<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; arr) {
        <span style="color:#0066cc;font-weight:bold;">int</span> maxLength = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp1 = GetLIS(arr); <span style="color:#008000;">// LIS: Left - &gt; Right</span>
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp2 = GetLDS(arr); <span style="color:#008000;">// LDS: Right -&gt; Left</span>

        <span style="color:#008000;">// At the same index If we take sum of both the longest Seqence</span>
        <span style="color:#008000;">// one with LIS Left-&gt;right, and other with LDS Right-&gt;Left</span>
        <span style="color:#008000;">// It will consider current element as peak element where direction of sequence is getting reversed</span>
        <span style="color:#008000;">// Since in both sequence this element considered twice so, will subtract 1 from sum</span>
        <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> i = <span style="color:#098658;">0</span>; i &lt; dp1.Length; i++)
        {
            maxLength = Math.Max(maxLength, dp1[i] + dp2[i] - <span style="color:#098658;">1</span>);
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> maxLength;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span>[] GetLIS(<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; arr)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[arr.Count];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;arr.Count; i++)
        {
            dp[i] = <span style="color:#098658;">1</span>;
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;i; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[i] &lt; <span style="color:#098658;">1</span>+dp[j])
                {
                    dp[i] = <span style="color:#098658;">1</span> + dp[j];
                }
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp;
    }
    
    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span>[] GetLDS(<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; arr)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> n = arr.Count;
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=n-<span style="color:#098658;">1</span>; i &gt;= <span style="color:#098658;">0</span> ; i--)
        {
            dp[i] = <span style="color:#098658;">1</span>;
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=n-<span style="color:#098658;">1</span>; j&gt;i; j--)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[i] &lt; <span style="color:#098658;">1</span>+dp[j])
                {
                    dp[i] = <span style="color:#098658;">1</span> + dp[j];
                }
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp;
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.6.5. Longest Divisible Subset</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array nums of positive integers, the task is to find the largest subset such that every pair (a, b) of elements in the subset satisfies a % b == 0 or b % a == 0.

Return the subset in any order. If there are multiple solutions, return any one of them.

Note: As there can be multiple correct answers, the compiler returns 1 if the answer is valid, else 0.

Examples:
Input: nums = [3, 5, 10, 20]

Output: [5, 10, 20]

Explanation:

The subset [5, 10, 20] satisfies the divisibility condition: 10 % 5 == 0 and 20 % 10 == 0.

Input: nums = [16, 8, 2, 4, 32]

Output: [2, 4, 8, 16, 32]

Explanation:

The entire array forms a divisible subset since 32 % 16 == 0, 16 % 8 == 0, and so on.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">// After Sorting the Array this problem has been converted into kind of problem where</span>
<span style="color:#008000;">// we need to find the longest chain which the divisible by previous element</span>
<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; LargestDivisibleSubset(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums)
    {
        <span style="color:#008000;">// Need to Sort Array as we need to make use of logic that</span>
        <span style="color:#008000;">// if element which can divide the current element should also be divisibe by</span>
        <span style="color:#008000;">// the elements which devides the current element which is dividing</span>

        <span style="color:#008000;font-weight:bold;">Array</span>.Sort(nums);
        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[nums.Length];
        <span style="color:#0066cc;font-weight:bold;">int</span>[] backtrack = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[nums.Length];

        <span style="color:#0066cc;font-weight:bold;">int</span> maxIndex = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> i = <span style="color:#098658;">0</span>; i &lt; nums.Length; i++)
        {
            dp[i] = <span style="color:#098658;">1</span>;
            backtrack[i] = i;

            <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> j = <span style="color:#098658;">0</span>; j &lt; i; j++)
            {
                <span style="color:#008000;">// Adjusted the logic here to check if % operation is giving &quot;Zero&quot;</span>
                <span style="color:#0066cc;font-weight:bold;">if</span> (nums[i] % nums[j] == <span style="color:#098658;">0</span> &amp;&amp; dp[i] &lt; dp[j] + <span style="color:#098658;">1</span>)
                {
                    dp[i] = <span style="color:#098658;">1</span> + dp[j];
                    backtrack[i] = j;
                }
            }

            <span style="color:#0066cc;font-weight:bold;">if</span> (dp[i] &gt; dp[maxIndex])
                maxIndex = i;
        }

        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        <span style="color:#0066cc;font-weight:bold;">while</span> (backtrack[maxIndex] != maxIndex)
        {
            res.Add(nums[maxIndex]);
            maxIndex = backtrack[maxIndex];
        }

        res.Add(nums[maxIndex]);

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.6.6. Longest Increasing Subsequence</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an integer array nums, return the length of the longest strictly increasing subsequence.

A subsequence is a sequence derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3, 6, 2, 7] is a subsequence of [0, 3, 1, 6, 2, 2, 7].

The task is to find the length of the longest subsequence in which every element is greater than the previous one.

Examples:
Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]

Output: 4

Explanation: The longest increasing subsequence is [2, 3, 7, 101], and its length is 4.

Input: nums = [0, 1, 0, 3, 2, 3]

Output: 4

Explanation: The longest increasing subsequence is [0, 1, 2, 3], and its length is 4
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">// Recursion + Memoization</span>
<span style="color:#008000;">// TC: O(N^2)</span>
<span style="color:#008000;">// SC: O(N^2) + O(N)</span>
<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> LIS(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> n = nums.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[nums.Length, nums.Length];
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(nums, <span style="color:#098658;">0</span>, -<span style="color:#098658;">1</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums, <span style="color:#0066cc;font-weight:bold;">int</span> index, <span style="color:#0066cc;font-weight:bold;">int</span> prev_index, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span> (index == nums.Length - <span style="color:#098658;">1</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span> (prev_index == -<span style="color:#098658;">1</span> || nums[index] &gt; nums[prev_index])
                <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">1</span>;
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span> (dp[index, prev_index + <span style="color:#098658;">1</span>] != <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, prev_index + <span style="color:#098658;">1</span>];

        <span style="color:#008000;">// Exclude</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = Solve(nums, index + <span style="color:#098658;">1</span>, prev_index, dp);

        <span style="color:#008000;">// Include</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res2 = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span> (prev_index == -<span style="color:#098658;">1</span> || nums[index] &gt; nums[prev_index])
        {
            res2 = <span style="color:#098658;">1</span> + Solve(nums, index + <span style="color:#098658;">1</span>, index, dp);
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, prev_index + <span style="color:#098658;">1</span>] = Math.Max(res1, res2);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.6.7. Longest String Chain</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
You are given an array of words where each word consists of lowercase English letters.

wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.

For example, &quot;abc&quot; is a predecessor of &quot;abac&quot;, while &quot;cba&quot; is not a predecessor of &quot;bcad&quot;.

A word chain is a sequence of words [word1, word2, ..., wordk] with k &gt;= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.

Return the length of the longest possible word chain with words chosen from the given list of words.


Examples:
Input: words = [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abcd&quot;, &quot;abcde&quot;]

Output: 5

Explanation: The longest chain is [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abcd&quot;, &quot;abcde&quot;].

Each word in the chain is formed by adding exactly one character to the previous word.

Input: words = [&quot;dog&quot;, &quot;dogs&quot;, &quot;dots&quot;, &quot;dot&quot;, &quot;d&quot;, &quot;do&quot;]

Output: 4

Explanation: The longest chain is [&quot;d&quot;, &quot;do&quot;, &quot;dot&quot;, &quot;dots&quot;].

Each word is formed by inserting one character into the previous word.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> LongestStringChain(<span style="color:#0066cc;font-weight:bold;">string</span>[] words)
    {
        <span style="color:#008000;font-weight:bold;">Array</span>.Sort(words, Compare); <span style="color:#008000;">// Using custom comparer to sort based on string length</span>

        <span style="color:#0066cc;font-weight:bold;">int</span>[] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[words.Length];

        <span style="color:#0066cc;font-weight:bold;">int</span> maxLength = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;words.Length; i++)
        {
            dp[i] = <span style="color:#098658;">1</span>;
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;i; j++)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span>(IsValiPredecessror(words[i], words[j]) &amp;&amp; dp[i] &lt; dp[j] + <span style="color:#098658;">1</span>)
                {
                    dp[i] = <span style="color:#098658;">1</span> + dp[j];
                }
            }

            <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i] &gt; maxLength)
            {
                maxLength = dp[i];
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> maxLength;
    }

    <span style="color:#008000;">// Custom comparator function </span>
    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">static</span> <span style="color:#0066cc;font-weight:bold;">int</span> Compare(<span style="color:#0066cc;font-weight:bold;">string</span> s, <span style="color:#0066cc;font-weight:bold;">string</span> t)
    {
        <span style="color:#0066cc;font-weight:bold;">return</span> s.Length.CompareTo(t.Length);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">bool</span> IsValiPredecessror(<span style="color:#0066cc;font-weight:bold;">string</span> s, <span style="color:#0066cc;font-weight:bold;">string</span> t)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(s.Length - t.Length != <span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> false;

        <span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>, j=<span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">while</span>(i &lt; s.Length)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(j &lt; t.Length &amp;&amp; s[i] == t[j])
            {
                i++;
                j++;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span>
            {
                i++;
            }
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(i == s.Length &amp;&amp; j == t.Length)
            <span style="color:#0066cc;font-weight:bold;">return</span> true;
        <span style="color:#0066cc;font-weight:bold;">return</span> false;
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h3 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 2.7. MCM</h3>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.7.1. Matrix Chain Multiplication</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a chain of matrices A1, A2, A3,.....An, you have to figure out the most efficient way to multiply these matrices. In other words, determine where to place parentheses to minimize the number of multiplications.

Given an array nums of size n. Dimension of matrix Ai ( 0 &lt; i &lt; n ) is nums[i - 1] x nums[i].Find a minimum number of multiplications needed to multiply the chain.

Examples:
Input : nums = [10, 15, 20, 25]

Output : 8000

Explanation : There are two ways to multiply the chain - A1*(A2*A3) or (A1*A2)*A3.

If we multiply in order- A1*(A2*A3), then number of multiplications required are 11250.

If we multiply in order- (A1*A2)*A3, then number of multiplications required are 8000.

Thus minimum number of multiplications required is 8000.

Input : nums = [4, 2, 3]

Output : 24

Explanation : There is only one way to multiply the chain - A1*A2.

Thus minimum number of multiplications required is 24.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> MatrixMultiplication(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums)
    {
        <span style="color:#008000;">//your code goes here</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> n = nums.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n, n];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;n; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;n; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> MCM(nums, <span style="color:#098658;">1</span>, n-<span style="color:#098658;">1</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> MCM(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(i == j)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }        

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,j] != -<span style="color:#098658;">1</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j];

        <span style="color:#0066cc;font-weight:bold;">int</span> min = <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue;

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> k=i; k&lt;j; k++)
        {
            <span style="color:#008000;">// consider the case for partition from i to k then k+1 to j-1. Where j = nums.Length-1</span>
            <span style="color:#0066cc;font-weight:bold;">int</span> ans = nums[i-<span style="color:#098658;">1</span>] * nums[k] * nums[j] + MCM(nums, i, k, dp) + MCM(nums, k+<span style="color:#098658;">1</span>, j, dp);
            min = Math.Min(min, ans);
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,j] = min;
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h3 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 2.8. Stocks</h3>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.8.1. Max Profit Best Time Buy Sell Stock</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array arr of n integers, where arr[i] represents price of the stock on the ith day. Determine the maximum profit achievable by buying and selling the stock at most once. 



The stock should be purchased before selling it, and both actions cannot occur on the same day.


Examples:
Input: arr = [10, 7, 5, 8, 11, 9]

Output: 6

Explanation: Buy on day 3 (price = 5) and sell on day 5 (price = 11), profit = 11 - 5 = 6.

Input: arr = [5, 4, 3, 2, 1]

Output: 0

Explanation: In this case, no transactions are made. Therefore, the maximum profit remains 0.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> stockBuySell(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> n)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(arr.Length == <span style="color:#098658;">1</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
       <span style="color:#0066cc;font-weight:bold;">int</span> buy = arr[<span style="color:#098658;">0</span>], sell = arr[<span style="color:#098658;">1</span>], profit = Math.Max(<span style="color:#098658;">0</span>, sell-buy);

       <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;n; i++)
       {
            <span style="color:#0066cc;font-weight:bold;">if</span>(arr[i] &lt; buy)
            {
                buy = arr[i];
                sell = buy;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span>(arr[i] &gt; sell)
            {
                sell = arr[i];
            }

            profit = Math.Max(profit, sell - buy);
       }

       <span style="color:#0066cc;font-weight:bold;">return</span> profit;
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.8.2. Max Profit With 2 Transactions</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array, arr, of n integers, where arr[i] represents the price of the stock on an ith day, determine the maximum profit achievable by completing at most two transactions in total.



Holding at most one share of the stock at any time is allowed, meaning buying and selling the stock twice is permitted, but the stock must be sold before buying it again. Buying and selling the stock on the same day is allowed.


Examples:
Input: arr = [4, 2, 7, 1, 11, 5]

Output: 15

Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 7), profit = 7 - 2 = 5. Then buy on day 4 (price = 1) and sell on day 5 (price = 11), profit = 11 - 1 = 10. Total profit is 5 + 10 = 15.

Input: arr = [1, 3, 2, 8, 4, 9]

Output: 12

Explanation: Buy on day 1 (price = 1) and sell on day 4 (price = 8), profit = 8 - 1 = 7. Then buy on day 5 (price = 4) and sell on day 6 (price = 9), profit = 9 - 4 = 5. Total profit is 7 + 5 = 12.

Input: arr = [5, 7, 2, 10, 6, 9]

Output:
11
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> StockBuySell(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> n)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n+<span style="color:#098658;">1</span>, <span style="color:#098658;">5</span>];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;n+<span style="color:#098658;">1</span>; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;<span style="color:#098658;">5</span>; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(arr, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">int</span> c, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(c == <span style="color:#098658;">4</span> || j == arr.Length)
        {
          <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[j,c] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[j,c];

        <span style="color:#0066cc;font-weight:bold;">if</span>(c % <span style="color:#098658;">2</span> == <span style="color:#098658;">0</span>) <span style="color:#008000;">// Buy</span>
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[j,c] = Math.Max(-arr[j] + Solve(arr, j+<span style="color:#098658;">1</span>, c+<span style="color:#098658;">1</span>, dp), Solve(arr, j+<span style="color:#098658;">1</span>, c, dp));
        }
        <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#008000;">// Sell</span>
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[j,c] = Math.Max(arr[j] + Solve(arr, j, c+<span style="color:#098658;">1</span>, dp), Solve(arr, j+<span style="color:#098658;">1</span>, c, dp));
        }
        
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.8.3. Max Profit With KTransaction</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array, arr, of n integers, where arr[i] represents the price of the stock on an ith day, determine the maximum profit achievable by completing at most k transactions in total. Holding at most one share of the stock at any given time is allowed, meaning buying and selling the stock k times is permitted, but the stock must be sold before buying it again. Buying and selling the stock on the same day is allowed.

Examples:
Input: arr = [3, 2, 6, 5, 0, 3], k = 2

Output: 7

Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6 - 2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3 - 0 = 3. Total profit is 4 + 3 = 7.

Input: arr = [1, 2, 4, 2, 5, 7, 2, 4, 9, 0], k = 3

Output: 15

Explanation: Buy on day 1 (price = 1) and sell on day 3 (price = 4), profit = 4 - 1 = 3. Then buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7 - 2 = 5. Then buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9 - 2 = 7. Total profit is 3 + 5 + 7 = 15.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> StockBuySell(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span> k)
    {
       <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n+<span style="color:#098658;">1</span>, <span style="color:#098658;">2</span>*k+<span style="color:#098658;">1</span>];

       <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;n+<span style="color:#098658;">1</span>; i++)
       {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;<span style="color:#098658;">2</span>*k+<span style="color:#098658;">1</span>; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
       }

       <span style="color:#0066cc;font-weight:bold;">return</span> Solve(arr, <span style="color:#098658;">0</span>, <span style="color:#098658;">2</span>*k, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> k, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(k == <span style="color:#098658;">0</span> || i == arr.Length)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,k] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,k];

        <span style="color:#008000;">// Buy</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(k % <span style="color:#098658;">2</span> == <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,k] = Math.Max(-arr[i] + Solve(arr, i+<span style="color:#098658;">1</span>, k-<span style="color:#098658;">1</span>, dp), Solve(arr, i+<span style="color:#098658;">1</span>, k, dp)); 
        }
        <span style="color:#0066cc;font-weight:bold;">else</span>
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,k] = Math.Max(arr[i] + Solve(arr, i+<span style="color:#098658;">1</span>, k-<span style="color:#098658;">1</span>, dp), Solve(arr, i+<span style="color:#098658;">1</span>, k, dp));
        }

    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.8.4. Max Profit With Transaction Fee</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array arr where arr[i] represents the price of a given stock on the ith day. Additionally, you are given an integer fee representing a transaction fee for each trade. The task is to determine the maximum profit you can achieve such that you need to pay a transaction fee for each buy and sell transaction. The Transaction Fee is applied when you sell a stock.

You may complete as many transactions. You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before buying again).


Examples:
Input: arr = [1, 3, 4, 0, 2], fee = 1

Output: 3

Explanation: Buy at day 1, sell at day 3, then, buy at day 4, sell at day 5.

Profit calculation: ((4 - 1) - 1) + ((2 - 0) - 1) = 2 + 1 = 3.

Input: arr = [1, 3, 2, 8, 4, 9], fee = 2

Output: 8

Explanation: Buy at day 1 (price = 1), sell at day 4 (price = 8), then Buy at day 5 (price = 4), sell at day 6 (price = 9),

Profit calculation: ((9 - 4) - 2) + ((8 - 1) - 2)= 8.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> stockBuySell(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span> fee)
    {
        <span style="color:#008000;">// Your code goes here</span>
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n, <span style="color:#098658;">2</span>];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;n; i++)
        {
            dp[i,<span style="color:#098658;">0</span>] = -<span style="color:#098658;">1</span>;
            dp[i,<span style="color:#098658;">1</span>] = -<span style="color:#098658;">1</span>;
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(arr, fee, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> fee, <span style="color:#0066cc;font-weight:bold;">int</span> buy, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(i == arr.Length)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[i,buy] != -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,buy];

        <span style="color:#0066cc;font-weight:bold;">if</span>(buy  == <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[i, buy] = Math.Max(-arr[i] + Solve(arr, fee, <span style="color:#098658;">1</span>, i+<span style="color:#098658;">1</span>, dp), Solve(arr, fee, <span style="color:#098658;">0</span>, i+<span style="color:#098658;">1</span>, dp));
        }
        <span style="color:#0066cc;font-weight:bold;">else</span>
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[i,buy] = Math.Max(arr[i]-fee + Solve(arr, fee, <span style="color:#098658;">0</span>, i, dp), Solve(arr, fee, <span style="color:#098658;">1</span>, i+<span style="color:#098658;">1</span>, dp));
        }
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.8.5. Total Profit Buy Sell Stock</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array arr of n integers, where arr[i] represents price of the stock on the ith day. Determine the maximum profit achievable by buying and selling the stock any number of times.



Holding at most one share of the stock at any given time is allowed, meaning buying and selling the stock can be done any number of times, but the stock must be sold before buying it again. Buying and selling the stock on the same day is permitted.


Examples:
Input: arr = [9, 2, 6, 4, 7, 3]

Output: 7

Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6 - 2 = 4. Then buy on day 4 (price = 4) and sell on day 5 (price = 7), profit = 7 - 4 = 3. Total profit is 4 + 3 = 7.

Input: arr = [2, 3, 4, 5, 6]

Output: 4

Explanation: Buy on day 1 (price = 2) and sell on day 5 (price = 6), profit = 6 - 2 = 4. Total profit is 4.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> StockBuySell(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> n)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(arr.Length == <span style="color:#098658;">1</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">int</span> profit = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">int</span> buy = arr[<span style="color:#098658;">0</span>], sell = arr[<span style="color:#098658;">1</span>];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">1</span>; i&lt;n; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(arr[i] &gt; buy)
            {
                profit += arr[i] - buy;
                buy = arr[i];
            }
            <span style="color:#0066cc;font-weight:bold;">else</span>
            {
                buy = arr[i];
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> profit;
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h3 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 2.9. Subset Subsequences</h3>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.9.1. Subset Partition Minimun Sum</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array arr of n integers, partition the array into two subsets such that 
the absolute difference between their sums is minimized.

Examples:
Input: arr = [1, 7, 14, 5]
Output: 1

Explanation: The array can be partitioned as [1, 7, 5] and [14], with an absolute difference of 1.

Input: arr = [3, 1, 6, 2, 2]
Output: 0

Explanation: The array can be partitioned as [3, 2, 2] and [6, 1], with an absolute difference of 0.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> minDifference(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> n)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> sum = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> i = <span style="color:#098658;">0</span>; i &lt; n; i++)
        {
            sum += arr[i];
        }

        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n, sum + <span style="color:#098658;">1</span>];
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve2(arr, n, sum, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dp);

    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve2(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span> totalSum, <span style="color:#0066cc;font-weight:bold;">int</span> s, <span style="color:#0066cc;font-weight:bold;">int</span> index, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span> (n == index)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> Math.Abs(totalSum - s - s);
        }

        <span style="color:#0066cc;font-weight:bold;">if</span> (dp[index, s] != <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, s];

        <span style="color:#008000;">// Include</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> sum1 = Solve2(arr, n, totalSum, s + arr[index], index + <span style="color:#098658;">1</span>, dp);
        <span style="color:#008000;">// Exclude</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> sum2 = Solve2(arr, n, totalSum, s, index + <span style="color:#098658;">1</span>, dp);

        dp[index, s] = Math.Min(sum1, sum2);

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, s];
    }

}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.9.2. Subset Sum Equal Partition</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array arr of n integers, return true if the array can be partitioned into 
two subsets such that the sum of elements in both subsets is equal else return false.

Examples:
Input: arr = [1, 10, 21, 10]
Output: True

Explanation: The array can be partitioned as [1, 10, 10] and [21].

Input: arr = [1, 2, 3, 5]
Output: False

Explanation: The array cannot be partitioned into equal sum subsets.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution {

    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">bool</span> EqualPartition(<span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span>[] arr) {
        <span style="color:#0066cc;font-weight:bold;">int</span> sum = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;arr.Length; i++)
        {
            sum += arr[i];
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(sum % <span style="color:#098658;">2</span> != <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> false;
        
        <span style="color:#0066cc;font-weight:bold;">int</span> target = sum / <span style="color:#098658;">2</span>;
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n, target+<span style="color:#098658;">1</span>];
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(arr, target, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">bool</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> target, <span style="color:#0066cc;font-weight:bold;">int</span> index, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>( index &gt;= arr.Length || target &lt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> false;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(target == <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> true;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[index, target] != <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, target] == <span style="color:#098658;">1</span>;

        dp[index, target] = Solve(arr, target - arr[index], index+<span style="color:#098658;">1</span>, dp);
        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[index, target] == <span style="color:#098658;">1</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> true;
        }
        <span style="color:#0066cc;font-weight:bold;">else</span>
        {
            dp[index, target] = -<span style="color:#098658;">1</span>;
        }
        
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(arr, target, index+<span style="color:#098658;">1</span>, dp);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.9.3. Sub Set Sum Equal To Target</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array arr of n integers and an integer target, determine if there is a subset 
of the given array with a sum equal to the given target.

Examples:
Input: arr = [1, 2, 7, 3], target = 6
Output: True

Explanation: There is a subset (1, 2, 3) with sum 6.

Input: arr = [2, 3, 5], target = 6
Output: False

Explanation: There is no subset with sum 6.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">// Here even without using the memoization it was able to pass all the Test cases</span>
<span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">bool</span> IsSubsetSum(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> target)
    {
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(arr, target, <span style="color:#098658;">0</span>);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">bool</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> target, <span style="color:#0066cc;font-weight:bold;">int</span> index)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span> (target == <span style="color:#098658;">0</span>) <span style="color:#0066cc;font-weight:bold;">return</span> true;

        <span style="color:#0066cc;font-weight:bold;">if</span> (index &gt;= arr.Length || target &lt; <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> false;

        <span style="color:#0066cc;font-weight:bold;">if</span> (target &gt;= arr[index])
        {
            <span style="color:#0066cc;font-weight:bold;">if</span> (Solve(arr, target - arr[index], index + <span style="color:#098658;">1</span>)) <span style="color:#0066cc;font-weight:bold;">return</span> true;
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(arr, target, index + <span style="color:#098658;">1</span>);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.9.4. Subset Sum To Target Count</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array arr of n integers and an integer K, count the number of subsets of the given array that have a sum equal to K. Return the result modulo (109 + 7).


Examples:
Input: arr = [2, 3, 5, 16, 8, 10], K = 10

Output: 3

Explanation: The subsets are [2, 8], [10], and [2, 3, 5].

Input: arr = [1, 2, 3, 4, 5], K = 5

Output: 3

Explanation: The subsets are [5], [2, 3], and [1, 4].
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> perfectSum(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> K)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[arr.Length, K+<span style="color:#098658;">1</span>];
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(arr, K, arr.Length-<span style="color:#098658;">1</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] arr, <span style="color:#0066cc;font-weight:bold;">int</span> K, <span style="color:#0066cc;font-weight:bold;">int</span> index, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(K == <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">1</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(index &lt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[index, K] != <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, K];

        <span style="color:#008000;">// Exclude</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = Solve(arr, K, index-<span style="color:#098658;">1</span>, dp);

        <span style="color:#008000;">// Include</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res2 = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(arr[index] &lt;= K)
        {
            res2 = Solve(arr, K - arr[index], index-<span style="color:#098658;">1</span>, dp);
        }

        dp[index, K] = (res1 % <span style="color:#098658;">1000000007</span> + res2 % <span style="color:#098658;">1000000007</span>) % <span style="color:#098658;">1000000007</span>;

        <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, K];
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.9.5. Target Sum</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an array nums of n integers and an integer target, build an expression using the integers from nums where each integer can be prefixed with either a &#x27;+&#x27; or &#x27;-&#x27; sign.

The goal is to achieve the target sum by evaluating all possible combinations of these signs.

Determine the number of ways to achieve the target sum and return your answer with modulo 10^9+7.

Examples:
Input: nums = [1, 2, 7, 1, 5], target = 4

Output: 2

Explanation: There are 2 ways to assign symbols to make the sum of nums be target 4.

+1 + 2 + 7 - 1 - 5 = 4

-1 + 2 + 7 + 1 - 5 = 4

Input: nums = [1], target = 1

Output: 1

Explanation: There is only one way to assign symbols to make the sum of nums be target 1.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> targetSum(<span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span> target, <span style="color:#0066cc;font-weight:bold;">int</span>[] nums)
    {
        <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;(<span style="color:#0066cc;font-weight:bold;">int</span>,<span style="color:#0066cc;font-weight:bold;">int</span>), <span style="color:#0066cc;font-weight:bold;">int</span>&gt; dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;(<span style="color:#0066cc;font-weight:bold;">int</span>,<span style="color:#0066cc;font-weight:bold;">int</span>), <span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(nums, target, n, <span style="color:#098658;">0</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] nums, <span style="color:#0066cc;font-weight:bold;">int</span> target, <span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span> index, <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;(<span style="color:#0066cc;font-weight:bold;">int</span>,<span style="color:#0066cc;font-weight:bold;">int</span>), <span style="color:#0066cc;font-weight:bold;">int</span>&gt; dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(index == n)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(target == <span style="color:#098658;">0</span>)
            {
                <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">1</span>;
            }
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp.ContainsKey((index, target)))
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[(index, target)];

        <span style="color:#0066cc;font-weight:bold;">int</span> res = Solve(nums, target - nums[index], n , index+<span style="color:#098658;">1</span>, dp) % <span style="color:#098658;">1000000007</span>+ Solve(nums, target+nums[index], n, index+<span style="color:#098658;">1</span>, dp) % <span style="color:#098658;">1000000007</span>;

        dp.Add((index, target), res % <span style="color:#098658;">1000000007</span>);
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[(index, target)];
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h3 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 2.10. Unbounded Knapsack</h3>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.10.1. Coin Change</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an integer array of coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that are needed to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. There are infinite numbers of coins of each type

Examples:
Input: coins = [1, 2, 5], amount = 11

Output: 3

Explanation: 11 = 5 + 5 + 1. We need 3 coins to make up the amount 11.

Input: coins = [2, 5], amount = 3

Output: -1

Explanation: It&#x27;s not possible to make amount 3 with coins 2 and 5. Since we can&#x27;t combine the coin 2 and 5 to make the amount 3, the output is -1.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> MinimumCoins(<span style="color:#0066cc;font-weight:bold;">int</span>[] coins, <span style="color:#0066cc;font-weight:bold;">int</span> amount)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[coins.Length, amount + <span style="color:#098658;">1</span>];
        <span style="color:#0066cc;font-weight:bold;">int</span> res = Solve(coins, amount, coins.Length-<span style="color:#098658;">1</span>, dp);
        <span style="color:#0066cc;font-weight:bold;">if</span>(res &lt; <span style="color:#098658;">0</span> || res == <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> -<span style="color:#098658;">1</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] coins, <span style="color:#0066cc;font-weight:bold;">int</span> amount, <span style="color:#0066cc;font-weight:bold;">int</span> index, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(index == <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(amount % coins[index] == <span style="color:#098658;">0</span>)
                <span style="color:#0066cc;font-weight:bold;">return</span> amount/coins[index];
            <span style="color:#0066cc;font-weight:bold;">else</span>
                <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(amount == <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        
        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[index, amount] != <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, amount];

        <span style="color:#008000;">// exclude corrent coin</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = Solve(coins, amount, index-<span style="color:#098658;">1</span>, dp);

        <span style="color:#0066cc;font-weight:bold;">int</span> res2 = <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue;
        
        <span style="color:#008000;">// include current Coin</span>
        <span style="color:#008000;">// Including the coin one by one and not by formula </span>
        <span style="color:#008000;">// amount/coins[index] : it becomes Greedy and doesn&#x27;t give the optimal solution</span>
        <span style="color:#008000;">// So, better try all the possible combinations to get optimized output</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(coins[index] &lt;= amount)
        {
            res2 = Solve(coins, amount - coins[index], index, dp);
            <span style="color:#0066cc;font-weight:bold;">if</span>(res2 != <span style="color:#0066cc;font-weight:bold;">int</span>.MaxValue)
            {
                res2 += <span style="color:#098658;">1</span>;
            }
        }

        dp[index, amount] = Math.Min(res1, res2);
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, amount];
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.10.2. Coin Change 2</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Give an array coins of n integers representing coin denominations. Your task is to find the number of distinct combinations that sum up to a specified amount of money. If it&#x27;s impossible to achieve the exact amount with any combination of coins, return 0.

Single coin can be used any number of times.

Return your answer with modulo 109+7.

Examples:
Input: coins = [2, 4,10], amount = 10
Output: 4

Explanation: The four combinations are:
10 = 10
10 = 4 + 4 + 2
10 = 4 + 2 + 2 + 2
10 = 2 + 2 + 2 + 2 + 2

Input: coins = [5], amount = 5
Output: 1
Explanation: There is one combination: 5 = 5.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">static</span> <span style="color:#0066cc;font-weight:bold;">int</span> MOD = (<span style="color:#0066cc;font-weight:bold;">int</span>)1e9 + <span style="color:#098658;">7</span>;

    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> count(<span style="color:#0066cc;font-weight:bold;">int</span>[] coins, <span style="color:#0066cc;font-weight:bold;">int</span> N, <span style="color:#0066cc;font-weight:bold;">int</span> amount)
    {

      <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[N, amount + <span style="color:#098658;">1</span>];

      <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;N; i++)
      {
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j &lt;= amount; j++)
        {
            dp[i,j] = -<span style="color:#098658;">1</span>;
        }
      }

      <span style="color:#0066cc;font-weight:bold;">return</span> Solve(coins, amount, N-<span style="color:#098658;">1</span>, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] coins, <span style="color:#0066cc;font-weight:bold;">int</span> amount, <span style="color:#0066cc;font-weight:bold;">int</span> index, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(amount == <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">1</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(index == -<span style="color:#098658;">1</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[index, amount] != -<span style="color:#098658;">1</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, amount];
        }

        <span style="color:#008000;">// Exclude</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = Solve(coins, amount, index-<span style="color:#098658;">1</span>, dp);

        <span style="color:#008000;">// Include</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res2 = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">if</span>(coins[index] &lt;= amount)
        {
            res2 = Solve(coins, amount - coins[index], index, dp);
        } 

        dp[index, amount] = (res1 % MOD + res2 % MOD) % MOD;
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, amount];
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.10.3. Rod Cutting Problem</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a rod of length N inches and an array price[] where price[i] denotes the value of a piece of rod of length i inches (1-based indexing). Determine the maximum value obtainable by cutting up the rod and selling the pieces. Make any number of cuts, or none at all, and sell the resulting pieces.

Examples:
Input: price = [1, 6, 8, 9, 10, 19, 7, 20], N = 8

Output: 25

Explanation: Cut the rod into lengths of 2 and 6 for a total price of 6 + 19= 25.

Input: price = [1, 5, 8, 9], N = 4

Output: 10

Explanation: Cut the rod into lengths of 2 and 2 for a total price of 5 + 5 = 10.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> RodCutting(<span style="color:#0066cc;font-weight:bold;">int</span>[] price, <span style="color:#0066cc;font-weight:bold;">int</span> n)
    {
        <span style="color:#008000;">// Initialize with &quot;price.Length+1&quot; instead of just &quot;price.Length&quot;</span>
        <span style="color:#008000;">// As we need to deal with &quot;1&quot; based index for price Array</span>
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[price.Length+<span style="color:#098658;">1</span>, n+<span style="color:#098658;">1</span>];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i &lt;= price.Length; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;=n; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(price, n, price.Length, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] price, <span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span> index, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(n == <span style="color:#098658;">0</span> || index == <span style="color:#098658;">0</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[index, n] != -<span style="color:#098658;">1</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, n];

        <span style="color:#008000;">// Exclude</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = Solve(price, n, index-<span style="color:#098658;">1</span>, dp);

        <span style="color:#008000;">// include</span>

        <span style="color:#008000;">// Note: Considering the 1 based index for Price Array but in actual it always stars from zero</span>
        <span style="color:#008000;">// So, To get actual price just use &quot;price[index-1]&quot; instead of price[index]</span>
        <span style="color:#008000;">// Index will refer &quot;1&quot; based as need to compute with &quot;n&quot; but price will refer &quot;0&quot; based as C# array are Zero based</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res2 = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">if</span>(index &lt;= n)
        {
            res2 = price[index-<span style="color:#098658;">1</span>] + Solve(price, n-index, index, dp);
        }

        dp[index, n] = Math.Max(res1, res2);
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, n];
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>2.10.4. Unbounded Knapsack</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given two integer arrays, val and wt, each of size N, representing the values and weights of N items respectively, and an integer W, representing the maximum capacity of a knapsack, determine the maximum value achievable by selecting a subset of the items such that the total weight of the selected items does not exceed the knapsack capacity W. The goal is to maximize the sum of the values of the selected items while keeping the total weight within the knapsack&#x27;s capacity.

An infinite supply of each item can be assumed.

Examples:
Input: val = [5, 11, 13], wt = [2, 4, 6], W = 10

Output: 27

Explanation: Select 2 items with weights 4 and 1 item with weight 2 for a total value of 11+11+5 = 27.

Input: val = [10, 40, 50, 70], wt = [1, 3, 4, 5], W = 8

Output: 110

Explanation: Select items with weights 3 and 5 for a total value of 40 + 70 = 110.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> UnboundedKnapsack(<span style="color:#0066cc;font-weight:bold;">int</span>[] wt, <span style="color:#0066cc;font-weight:bold;">int</span>[] val, <span style="color:#0066cc;font-weight:bold;">int</span> n, <span style="color:#0066cc;font-weight:bold;">int</span> W) {
        <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n, W+<span style="color:#098658;">1</span>];

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;n; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> j=<span style="color:#098658;">0</span>; j&lt;=W; j++)
            {
                dp[i,j] = -<span style="color:#098658;">1</span>;
            }
        }
            
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(wt, val, n-<span style="color:#098658;">1</span>, W, dp);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#0066cc;font-weight:bold;">int</span>[] wt, <span style="color:#0066cc;font-weight:bold;">int</span>[] val, <span style="color:#0066cc;font-weight:bold;">int</span> index, <span style="color:#0066cc;font-weight:bold;">int</span> W, <span style="color:#0066cc;font-weight:bold;">int</span>[,] dp)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(W == <span style="color:#098658;">0</span> || index == -<span style="color:#098658;">1</span>)
            <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(dp[index, W] != -<span style="color:#098658;">1</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, W];
        }

        <span style="color:#008000;">// Exclude</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res1 = Solve(wt, val, index-<span style="color:#098658;">1</span>, W, dp);

        <span style="color:#008000;">// Include</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> res2 = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">if</span>(wt[index] &lt;= W)
        {
            res2 = val[index] + Solve(wt, val, index, W - wt[index], dp);
        }
        
        dp[index, W] = Math.Max(res1, res2);
        <span style="color:#0066cc;font-weight:bold;">return</span> dp[index, W];
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h2 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 3. Graph</h2>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>3.1. BFS</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
BFS Implementation for graph with &#x27;n&#x27; nodes
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Graph
{
    <span style="color:#0066cc;font-weight:bold;">void</span> BFS(GraphNode root, <span style="color:#0066cc;font-weight:bold;">int</span> n)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[] visited = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n];
        <span style="color:#008000;font-weight:bold;">Queue</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; q = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Queue</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        q.Enqueue(root.Value);
        visited[root.Value] = <span style="color:#098658;">1</span>;

        <span style="color:#0066cc;font-weight:bold;">while</span> (q.Count != <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">var</span> currentNode = q.Dequeue();
            Console.WriteLine(currentNode.Value);

            <span style="color:#0066cc;font-weight:bold;">foreach</span> (<span style="color:#0066cc;font-weight:bold;">var</span> neighbor <span style="color:#0066cc;font-weight:bold;">in</span> currentNode.Neighbors)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span> (visited[neighbor.Value] == <span style="color:#098658;">0</span>)
                {
                    q.Enqueue(neighbor.Value);
                    visited[neighbor.Value] = <span style="color:#098658;">1</span>;
                }  
            }
        }
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>3.2. Clone Graph</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">Node</span> CloneGraph(<span style="color:#008000;font-weight:bold;">Node</span> node) {
        <span style="color:#0066cc;font-weight:bold;">if</span>(node == null)
            <span style="color:#0066cc;font-weight:bold;">return</span> node;
        <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#008000;font-weight:bold;">Node</span>&gt; map = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#008000;font-weight:bold;">Node</span>&gt;();
        CloneNodes(node, map);
        <span style="color:#0066cc;font-weight:bold;">return</span> map[<span style="color:#098658;">1</span>];
        
    }
    
    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> CloneNodes(<span style="color:#008000;font-weight:bold;">Node</span> node, <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#008000;font-weight:bold;">Node</span>&gt; map)
    {
        <span style="color:#008000;font-weight:bold;">Node</span> newNode = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Node</span>(node.val);
        newNode.neighbors = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">Node</span>&gt;();
        
        map.Add(newNode.val, newNode);
        <span style="color:#0066cc;font-weight:bold;">foreach</span>(<span style="color:#008000;font-weight:bold;">Node</span> n <span style="color:#0066cc;font-weight:bold;">in</span> node.neighbors)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(!map.ContainsKey(n.val))
                CloneNodes(n,map);
            newNode.neighbors.Add(map[n.val]);
            
        }
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>3.3. DFS</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Using DFS to traverse a graph using recursion(in-built call stack)
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Graph
{
    <span style="color:#008000;font-weight:bold;">HashSet</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; visited = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">HashSet</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">void</span> DFS(GraphNode node, <span style="color:#008000;font-weight:bold;">HashSet</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; visited)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span> (node == null || visited.Contains(node.Value))
            <span style="color:#0066cc;font-weight:bold;">return</span>;

        Console.WriteLine(node.Value);
        visited.Add(node.Value);

        <span style="color:#0066cc;font-weight:bold;">foreach</span> (<span style="color:#0066cc;font-weight:bold;">var</span> neighbor <span style="color:#0066cc;font-weight:bold;">in</span> node.Neighbors)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span> (!visited.Contains(neighbor.Value))
            {
                DFS(neighbor, visited);
            }
        }
    }
}

<span style="color:#008000;">// Using DFS to traverse a graph using an explicit stack</span>
<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> GraphIterative
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">void</span> DFS(GraphNode root, <span style="color:#0066cc;font-weight:bold;">int</span> n)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span>[] visited = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[n];
        <span style="color:#008000;font-weight:bold;">Stack</span>&lt;GraphNode&gt; stack = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Stack</span>&lt;GraphNode&gt;();

        stack.Push(root);

        <span style="color:#0066cc;font-weight:bold;">while</span> (stack.Count != <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">var</span> currentNode = stack.Pop();

            <span style="color:#0066cc;font-weight:bold;">if</span> (visited[currentNode.Value] == <span style="color:#098658;">1</span>)
                continue;

            Console.WriteLine(currentNode.Value);
            visited[currentNode.Value] = <span style="color:#098658;">1</span>;

            <span style="color:#0066cc;font-weight:bold;">foreach</span> (<span style="color:#0066cc;font-weight:bold;">var</span> neighbor <span style="color:#0066cc;font-weight:bold;">in</span> currentNode.Neighbors)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span> (visited[neighbor.Value] == <span style="color:#098658;">0</span>)
                {
                    stack.Push(neighbor);
                }
            }
        }
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>3.4. Graph Node</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> GraphNode
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> Value { get; <span style="color:#0066cc;font-weight:bold;">private</span> set; }
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;GraphNode&gt; Neighbors;

    <span style="color:#0066cc;font-weight:bold;">public</span> GraphNode(<span style="color:#0066cc;font-weight:bold;">int</span> value)
    {
        Value = value;
        Neighbors = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;GraphNode&gt;();
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>3.5. Num Islands</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
	
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> NumIslands(char[][] grid) {
		<span style="color:#0066cc;font-weight:bold;">int</span> islandCount =<span style="color:#098658;">0</span>;
		<span style="color:#0066cc;font-weight:bold;">bool</span>[,] visitorMatirx = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">bool</span>[grid.Length, grid[<span style="color:#098658;">0</span>].Length];
		
		<span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> row=<span style="color:#098658;">0</span>; row &lt; grid.Length; row++)
		{
			<span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> col=<span style="color:#098658;">0</span>; col &lt; grid[<span style="color:#098658;">0</span>].Length; col++)
			{
				visitorMatirx[row,col] = false;
			}
		}
		
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> row=<span style="color:#098658;">0</span>; row &lt; grid.Length; row++)
		{
			<span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> col=<span style="color:#098658;">0</span>; col &lt; grid[<span style="color:#098658;">0</span>].Length; col++)
			{
				<span style="color:#0066cc;font-weight:bold;">if</span>(grid[row][col] == &#x27;<span style="color:#098658;">1</span>&#x27; &amp;&amp; visitorMatirx[row,col] == false)
				{
					DFS(grid,row,col,visitorMatirx);
					islandCount++;
				}					
			}
		}
		
		<span style="color:#0066cc;font-weight:bold;">return</span> islandCount;
    }
	
	<span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> DFS(char[][] grid, <span style="color:#0066cc;font-weight:bold;">int</span> i, <span style="color:#0066cc;font-weight:bold;">int</span> j, <span style="color:#0066cc;font-weight:bold;">bool</span>[,] visitorMatirx)
	{
        
		<span style="color:#0066cc;font-weight:bold;">if</span>(i &lt; grid.Length &amp;&amp; j &lt; grid[<span style="color:#098658;">0</span>].Length &amp;&amp; i &gt;= <span style="color:#098658;">0</span> &amp;&amp; j &gt;= <span style="color:#098658;">0</span> &amp;&amp; grid[i][j] != &#x27;<span style="color:#098658;">0</span>&#x27; &amp;&amp; !visitorMatirx[i,j])	
		{
			visitorMatirx[i,j] = true;
			DFS(grid, i+<span style="color:#098658;">1</span>,j, visitorMatirx);
            DFS(grid, i-<span style="color:#098658;">1</span>,j, visitorMatirx);
			DFS(grid, i,j+<span style="color:#098658;">1</span>, visitorMatirx);
			DFS(grid, i,j-<span style="color:#098658;">1</span>, visitorMatirx);
		}
	}
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>3.6. Rotting Oranges</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> OrangesRotting(<span style="color:#0066cc;font-weight:bold;">int</span>[][] grid) {
        <span style="color:#0066cc;font-weight:bold;">int</span> rows = grid.Length;
        <span style="color:#0066cc;font-weight:bold;">int</span> cols = grid[<span style="color:#098658;">0</span>].Length;
        <span style="color:#0066cc;font-weight:bold;">bool</span>[,] visited = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">bool</span>[rows, cols];
        <span style="color:#008000;font-weight:bold;">Queue</span>&lt;(<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#0066cc;font-weight:bold;">int</span>)&gt; queue = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Queue</span>&lt;(<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#0066cc;font-weight:bold;">int</span>)&gt;();
        <span style="color:#0066cc;font-weight:bold;">int</span> freshCount = <span style="color:#098658;">0</span>;
        <span style="color:#0066cc;font-weight:bold;">int</span> minutes = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> r = <span style="color:#098658;">0</span>; r &lt; rows; r++) {
            <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> c = <span style="color:#098658;">0</span>; c &lt; cols; c++) {
                <span style="color:#0066cc;font-weight:bold;">if</span> (grid[r][c] == <span style="color:#098658;">2</span>) {
                    queue.Enqueue((r, c));
                    visited[r, c] = true;
                } <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span> (grid[r][c] == <span style="color:#098658;">1</span>) {
                    freshCount++;
                }
            }
        }

        <span style="color:#0066cc;font-weight:bold;">int</span>[][] directions = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[][] {
            <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[] {<span style="color:#098658;">1</span>, <span style="color:#098658;">0</span>},
            <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[] {-<span style="color:#098658;">1</span>, <span style="color:#098658;">0</span>},
            <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[] {<span style="color:#098658;">0</span>, <span style="color:#098658;">1</span>},
            <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[] {<span style="color:#098658;">0</span>, -<span style="color:#098658;">1</span>}
        };

        <span style="color:#0066cc;font-weight:bold;">while</span> (queue.Count &gt; <span style="color:#098658;">0</span> &amp;&amp; freshCount &gt; <span style="color:#098658;">0</span>) {
            <span style="color:#0066cc;font-weight:bold;">int</span> size = queue.Count;
            <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> i = <span style="color:#098658;">0</span>; i &lt; size; i++) {
                <span style="color:#0066cc;font-weight:bold;">var</span> (r, c) = queue.Dequeue();
                <span style="color:#0066cc;font-weight:bold;">foreach</span> (<span style="color:#0066cc;font-weight:bold;">var</span> dir <span style="color:#0066cc;font-weight:bold;">in</span> directions) {
                    <span style="color:#0066cc;font-weight:bold;">int</span> newRow = r + dir[<span style="color:#098658;">0</span>];
                    <span style="color:#0066cc;font-weight:bold;">int</span> newCol = c + dir[<span style="color:#098658;">1</span>];
                    <span style="color:#0066cc;font-weight:bold;">if</span> (newRow &gt;= <span style="color:#098658;">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newCol &gt;= <span style="color:#098658;">0</span> &amp;&amp; newCol &lt; cols &amp;&amp;
                        grid[newRow][newCol] == <span style="color:#098658;">1</span> &amp;&amp; !visited[newRow, newCol]) {
                        visited[newRow, newCol] = true;
                        grid[newRow][newCol] = <span style="color:#098658;">2</span>;
                        freshCount--;
                        queue.Enqueue((newRow, newCol));
                    }
                }
            }
            minutes++;
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> freshCount == <span style="color:#098658;">0</span> ? minutes : -<span style="color:#098658;">1</span>;
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>3.7. SCC_Kosaraju_Algorithm</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> SCC_Kosaraju_Algorithm
{
    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; FindSCCs(<span style="color:#0066cc;font-weight:bold;">int</span> vertices, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; adj)
    {
        <span style="color:#008000;">// Step 1: Perform DFS and store the finish order</span>
        <span style="color:#008000;font-weight:bold;">Stack</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; finishStack = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Stack</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
        <span style="color:#0066cc;font-weight:bold;">bool</span>[] visited = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">bool</span>[vertices];

        <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> i = <span style="color:#098658;">0</span>; i &lt; vertices; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span> (!visited[i])
            {
                DFS(i, adj, visited, finishStack);
            }
        }

        <span style="color:#008000;">// Step 2: Transpose the graph</span>
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; transposedAdj = TransposeGraph(vertices, adj);

        <span style="color:#008000;">// Step 3: Perform DFS on transposed graph in finish order</span>
        visited = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">bool</span>[vertices];
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; sccs = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;();
        <span style="color:#0066cc;font-weight:bold;">while</span> (finishStack.Count &gt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">int</span> node = finishStack.Pop();
            <span style="color:#0066cc;font-weight:bold;">if</span> (!visited[node])
            {
                <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; currentSCC = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
                DFS_Transpose(node, transposedAdj, visited, currentSCC);
                sccs.Add(currentSCC);
            }
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> sccs;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> DFS(<span style="color:#0066cc;font-weight:bold;">int</span> node, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; adj, <span style="color:#0066cc;font-weight:bold;">bool</span>[] visited, <span style="color:#008000;font-weight:bold;">Stack</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; finishStack)
    {
        visited[node] = true;
        <span style="color:#0066cc;font-weight:bold;">foreach</span> (<span style="color:#0066cc;font-weight:bold;">var</span> neighbor <span style="color:#0066cc;font-weight:bold;">in</span> adj[node])
        {
            <span style="color:#0066cc;font-weight:bold;">if</span> (!visited[neighbor])
            {
                DFS(neighbor, adj, visited, finishStack);
            }
        }
        finishStack.Push(node);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; TransposeGraph(<span style="color:#0066cc;font-weight:bold;">int</span> vertices, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; adj)
    {
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; transposedAdj = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;();
        <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> i = <span style="color:#098658;">0</span>; i &lt; vertices; i++)
        {
            transposedAdj.Add(<span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;());
        }

        <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> i = <span style="color:#098658;">0</span>; i &lt; vertices; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">foreach</span> (<span style="color:#0066cc;font-weight:bold;">var</span> neighbor <span style="color:#0066cc;font-weight:bold;">in</span> adj[i])
            {
                transposedAdj[neighbor].Add(i);
            }
        }
        <span style="color:#0066cc;font-weight:bold;">return</span> transposedAdj;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> DFS_Transpose(<span style="color:#0066cc;font-weight:bold;">int</span> node, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; transposedAdj, <span style="color:#0066cc;font-weight:bold;">bool</span>[] visited, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; currentSCC)
    {
        visited[node] = true;
        currentSCC.Add(node);
        <span style="color:#0066cc;font-weight:bold;">foreach</span> (<span style="color:#0066cc;font-weight:bold;">var</span> neighbor <span style="color:#0066cc;font-weight:bold;">in</span> transposedAdj[node])
        {
            <span style="color:#0066cc;font-weight:bold;">if</span> (!visited[neighbor])
            {
                DFS_Transpose(neighbor, transposedAdj, visited, currentSCC);
            }
        }
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h2 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 4. String Problems</h2>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>4.1. Count And Say</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

countAndSay(1) = &quot;1&quot;
countAndSay(n) is the run-length encoding of countAndSay(n - 1).
Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string &quot;3322251&quot; we replace &quot;33&quot; with &quot;23&quot;, replace &quot;222&quot; with &quot;32&quot;, replace &quot;5&quot; with &quot;15&quot; and replace &quot;1&quot; with &quot;11&quot;. Thus the compressed string becomes &quot;23321511&quot;.

Given a positive integer n, return the nth element of the count-and-say sequence.

 

Example 1:

Input: n = 4

Output: &quot;1211&quot;

Explanation:

countAndSay(1) = &quot;1&quot;
countAndSay(2) = RLE of &quot;1&quot; = &quot;11&quot;
countAndSay(3) = RLE of &quot;11&quot; = &quot;21&quot;
countAndSay(4) = RLE of &quot;21&quot; = &quot;1211&quot;
Example 2:

Input: n = 1

Output: &quot;1&quot;

Explanation:

This is the base case.

 

Constraints:

1 &lt;= n &lt;= 30
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">// LeetCode: 38. Count and Say</span>

<span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">string</span> CountAndSay(<span style="color:#0066cc;font-weight:bold;">int</span> n) {

        <span style="color:#0066cc;font-weight:bold;">string</span> ans = &quot;<span style="color:#098658;">1</span>&quot;;
        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">2</span>; i&lt;=n; i++)
        {
            ans = Solve(ans);
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> ans;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">string</span> Solve(<span style="color:#0066cc;font-weight:bold;">string</span> s)
    {
        <span style="color:#0066cc;font-weight:bold;">int</span> count = <span style="color:#098658;">0</span>;
        char current = s[<span style="color:#098658;">0</span>];
        <span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>;

        StringBuilder sb = <span style="color:#0066cc;font-weight:bold;">new</span> StringBuilder();

        <span style="color:#0066cc;font-weight:bold;">while</span>(i &lt; s.Length)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(s[i] == current)
            {
                count++;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span>
            {
                sb.Append($&quot;{count}{s[i-<span style="color:#098658;">1</span>]}&quot;);
                current = s[i];
                count = <span style="color:#098658;">1</span>;
            }
            i++;
        }

        sb.Append($&quot;{count}{s[i-<span style="color:#098658;">1</span>]}&quot;);

        <span style="color:#0066cc;font-weight:bold;">return</span> sb.ToString();
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>4.2. Pattern Match Index</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a string text and a string pattern, implement the Rabin-Karp algorithm to find the starting index of all occurrences of pattern in text. If pattern is not found, return an empty list.

Examples:
Input: text = &quot;ababcabcababc&quot;, pattern = &quot;abc&quot;


Output: [2, 5, 10]

Expalanation : The pattern &quot;abc&quot; is found at indices 2, 5, and 10 in the text.

Input: text = &quot;hello&quot;, pattern = &quot;ll&quot;

Output: [2]

Explanation: The pattern &quot;ll&quot; is found at index 2 in the text.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; search(<span style="color:#0066cc;font-weight:bold;">string</span> pat, <span style="color:#0066cc;font-weight:bold;">string</span> txt)
    {
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        <span style="color:#0066cc;font-weight:bold;">if</span>(pat.Length &gt; txt.Length) <span style="color:#0066cc;font-weight:bold;">return</span> res;

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;txt.Length; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(txt[i] == pat[<span style="color:#098658;">0</span>])
            {
                <span style="color:#0066cc;font-weight:bold;">int</span> k =<span style="color:#098658;">0</span>;
                <span style="color:#0066cc;font-weight:bold;">while</span>(k &lt; pat.Length &amp;&amp; i+k &lt; txt.Length &amp;&amp; txt[i+k] == pat[k])
                {
                    k++;
                }
                <span style="color:#0066cc;font-weight:bold;">if</span>(k == pat.Length) res.Add(i);
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>4.3. Reverse Every Word In String</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given an input string, containing upper-case and lower-case letters, digits, and spaces( &#x27; &#x27; ). A word is defined as a sequence of non-space characters. The words in s are separated by at least one space.

Return a string with the words in reverse order, concatenated by a single space.

Examples:
Input: s = &quot;welcome to the jungle&quot;

Output: &quot;jungle the to welcome&quot;

Explanation: The words in the input string are &quot;welcome&quot;, &quot;to&quot;, &quot;the&quot;, and &quot;jungle&quot;. Reversing the order of these words gives &quot;jungle&quot;, &quot;the&quot;, &quot;to&quot;, and &quot;welcome&quot;. The output string should have exactly one space between each word.

Input: s = &quot; amazing coding skills &quot;

Output: &quot;skills coding amazing&quot;

Explanation: The input string has leading and trailing spaces, as well as multiple spaces between the words &quot;amazing&quot;, &quot;coding&quot;, and &quot;skills&quot;. After trimming the leading and trailing spaces and reducing the multiple spaces between words to a single space, the words are &quot;amazing&quot;, &quot;coding&quot;, and &quot;skills&quot;. Reversing the order of these words gives &quot;skills&quot;, &quot;coding&quot;, and &quot;amazing&quot;. The output string should not have any leading or trailing spaces and should have exactly one space between each word.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">using</span> System.Text;

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">string</span> ReverseWords(<span style="color:#0066cc;font-weight:bold;">string</span> s)
    {
        <span style="color:#008000;font-weight:bold;">Stack</span>&lt;<span style="color:#0066cc;font-weight:bold;">string</span>&gt; stk = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Stack</span>&lt;<span style="color:#0066cc;font-weight:bold;">string</span>&gt;();
        StringBuilder sb = <span style="color:#0066cc;font-weight:bold;">new</span> StringBuilder();

        <span style="color:#0066cc;font-weight:bold;">bool</span> shouldPush = false;

        <span style="color:#0066cc;font-weight:bold;">for</span> (<span style="color:#0066cc;font-weight:bold;">int</span> i = <span style="color:#098658;">0</span>; i &lt; s.Length; i++)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span> (s[i] != &#x27; &#x27;)
            {
                <span style="color:#0066cc;font-weight:bold;">if</span> (shouldPush)
                {
                    stk.Push(sb.ToString());
                    sb = <span style="color:#0066cc;font-weight:bold;">new</span> StringBuilder();
                    shouldPush = false;
                }
                sb.Append(s[i]);

            }
            <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span> (s[i] == &#x27; &#x27;)
            {
                shouldPush = true;
            }
        }

        stk.Push(sb.ToString());
        sb = <span style="color:#0066cc;font-weight:bold;">new</span> StringBuilder();

        <span style="color:#0066cc;font-weight:bold;">while</span> (stk.Count &gt; <span style="color:#098658;">0</span>)
        {
            sb.Append(stk.Pop());
            sb.Append(&quot; &quot;);
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> sb.ToString();
    }
}

<span style="color:#008000;">// In-Place reversal without using much extra Space</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">string</span> ReverseWords(<span style="color:#0066cc;font-weight:bold;">string</span> s) {
        <span style="color:#008000;font-weight:bold;">Stack</span>&lt;char&gt; stk = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Stack</span>&lt;char&gt;();
        StringBuilder sb = <span style="color:#0066cc;font-weight:bold;">new</span> StringBuilder();

        <span style="color:#0066cc;font-weight:bold;">int</span> n = s.Length-<span style="color:#098658;">1</span>;
        <span style="color:#0066cc;font-weight:bold;">while</span>(n &gt;= <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(s[n] != &#x27; &#x27;)
            {
                stk.Push(s[n]);
            }
            <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span>(s[n] == &#x27; &#x27; &amp;&amp; stk.Count &gt; <span style="color:#098658;">0</span>)
            {
                <span style="color:#0066cc;font-weight:bold;">while</span>(stk.Count &gt; <span style="color:#098658;">0</span>)
                {
                    sb.Append(stk.Pop());
                }
                sb.Append(&quot; &quot;);
            }
            n--;
        }

        <span style="color:#0066cc;font-weight:bold;">while</span>(stk.Count &gt; <span style="color:#098658;">0</span>)
        {
            sb.Append(stk.Pop());
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> sb.ToString();
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>4.4. Shortest Palindrome</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
You are given a string s. You can convert s to a palindrome by adding characters in front of it.

Return the shortest palindrome you can find by performing this transformation.

Example 1:

Input: s = &quot;aacecaaa&quot;
Output: &quot;aaacecaaa&quot;
Example 2:

Input: s = &quot;abcd&quot;
Output: &quot;dcbabcd&quot;
 

Constraints:

0 &lt;= s.length &lt;= 5 * 104
s consists of lowercase English letters only.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">// TODO: Need to write the Code</span></pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<h2 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 5. Tree</h2>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.1. Count Nodes</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Return the number of nodes in a binary tree given its root.
Every level in a complete binary tree possibly with the exception of the final one is fully filled, and every node in the final level is as far to the left as it can be. At the last level h, it can have 1 to 2h nodes inclusive.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/*
 // Definition for a binary tree node.
 public class TreeNode {
     public int val;
     public TreeNode left;
     public TreeNode right;

     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {
         this.val = val;
         this.left = left;
         this.right = right;
     }
 }
*/</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> CountNodes(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {

        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">1</span> + CountNodes(root.left) + CountNodes(root.right);
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.2. Diameter Of Tree</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root of a binary tree, return the length of the diameter of the tree.
The diameter of a binary tree is the length of the longest path between any two nodes in the tree. It may or may not pass through the root.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">int</span> diameter = <span style="color:#098658;">0</span>;

    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> DiameterOfBinaryTree(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#008000;">//your code goes here</span>
        Solve(root);
        <span style="color:#0066cc;font-weight:bold;">return</span> diameter;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#008000;font-weight:bold;">TreeNode</span> root)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">int</span> lh = Solve(root.left);

        <span style="color:#0066cc;font-weight:bold;">int</span> rh = Solve(root.right);

        diameter = Math.Max(diameter, lh+rh);    
        <span style="color:#0066cc;font-weight:bold;">return</span> Math.Max(lh, rh) + <span style="color:#098658;">1</span>;
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.3. Height Balanced Tree</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a binary tree root, find if it is height-balanced or not.
A tree is height-balanced if the difference between the heights of left and right subtrees is not more than one for all nodes of the tree.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">bool</span> IsBalanced(<span style="color:#008000;font-weight:bold;">TreeNode</span> root)
    {
        <span style="color:#0066cc;font-weight:bold;">return</span> Height(root) != -<span style="color:#098658;">1</span>;
    }

    <span style="color:#008000;">// Returns height if balanced, -1 if not</span>
    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Height(<span style="color:#008000;font-weight:bold;">TreeNode</span> node)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(node == null) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">int</span> leftHeight = Height(node.left);
        <span style="color:#0066cc;font-weight:bold;">if</span>(leftHeight == -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> -<span style="color:#098658;">1</span>;

        <span style="color:#0066cc;font-weight:bold;">int</span> rightHeight = Height(node.right);
        <span style="color:#0066cc;font-weight:bold;">if</span>(rightHeight == -<span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> -<span style="color:#098658;">1</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(Math.Abs(leftHeight - rightHeight) &gt; <span style="color:#098658;">1</span>) <span style="color:#0066cc;font-weight:bold;">return</span> -<span style="color:#098658;">1</span>;

        <span style="color:#0066cc;font-weight:bold;">return</span> Math.Max(leftHeight, rightHeight) + <span style="color:#098658;">1</span>;
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.4. Identical Tree</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the roots of two binary trees p and q, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">bool</span> IsSameTree(<span style="color:#008000;font-weight:bold;">TreeNode</span> p, <span style="color:#008000;font-weight:bold;">TreeNode</span> q) {
        <span style="color:#008000;">//your code goes here</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(p == null &amp;&amp; q == null) <span style="color:#0066cc;font-weight:bold;">return</span> true;
        <span style="color:#0066cc;font-weight:bold;">if</span>(p == null || q == null) <span style="color:#0066cc;font-weight:bold;">return</span> false;
        <span style="color:#0066cc;font-weight:bold;">if</span>(p.val != q.val) <span style="color:#0066cc;font-weight:bold;">return</span> false;

        <span style="color:#0066cc;font-weight:bold;">return</span> p.val == q.val &amp;&amp; IsSameTree(p.left, q.left) &amp;&amp; IsSameTree(p.right, q.right);
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.5. Longest Common Ancestor</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a root of binary tree, find the lowest common ancestor (LCA) of two given nodes (p, q) in the tree.
The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">TreeNode</span> LowestCommonAncestor(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">TreeNode</span> p, <span style="color:#008000;font-weight:bold;">TreeNode</span> q) {
        <span style="color:#008000;">// your code goes here</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> root;

        <span style="color:#0066cc;font-weight:bold;">if</span>(root.val == p.val || root.val == q.val) <span style="color:#0066cc;font-weight:bold;">return</span> root;

        <span style="color:#008000;font-weight:bold;">TreeNode</span> left = LowestCommonAncestor(root.left, p, q);
        <span style="color:#008000;font-weight:bold;">TreeNode</span> right = LowestCommonAncestor(root.right, p, q);

        <span style="color:#0066cc;font-weight:bold;">if</span>(left == null) <span style="color:#0066cc;font-weight:bold;">return</span> right; <span style="color:#008000;">// both nodes can be in right side and this node is the parent</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(right == null) <span style="color:#0066cc;font-weight:bold;">return</span> left; <span style="color:#008000;">// both nodes can be in left side and this node is the parent</span>
        
        <span style="color:#0066cc;font-weight:bold;">return</span> root; <span style="color:#008000;">// This root is the parent as both side is not null</span>
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.6. Max Depth</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given root of the binary tree, return its maximum depth.
A binary tree&#x27;s maximum depth is number of nodes along the longest path from root node down to the farthest node.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> maxDepth(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#008000;">//your code goes here</span>

        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">int</span> lh = <span style="color:#098658;">1</span> + maxDepth(root.left);
        <span style="color:#0066cc;font-weight:bold;">int</span> rh = <span style="color:#098658;">1</span> + maxDepth(root.right);

        <span style="color:#0066cc;font-weight:bold;">return</span> Math.Max(lh, rh);
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.7. Max Path Sum</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
In a binary tree, a path is a list of nodes where there is an edge between every pair of neighbouring nodes. A node may only make a single appearance in the sequence.

The total of each node&#x27;s values along a path is its path sum. Return the largest path sum of all non-empty paths given the root of a binary tree.

Note: The path does not have to go via the root.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {

    <span style="color:#0066cc;font-weight:bold;">int</span> maxPathVal = <span style="color:#0066cc;font-weight:bold;">int</span>.MinValue;
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> MaxPathSum(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#008000;">//your code goes here</span>

        Solve(root);
        <span style="color:#0066cc;font-weight:bold;">return</span> maxPathVal;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">int</span> Solve(<span style="color:#008000;font-weight:bold;">TreeNode</span> root)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> <span style="color:#098658;">0</span>;

        <span style="color:#008000;">// If Path Length is -ve then just ignore as it won&#x27;t contribute in maxPath Length</span>
        <span style="color:#008000;">// and should be discarded</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> leftSum = Math.Max(<span style="color:#098658;">0</span>, Solve(root.left));
        <span style="color:#0066cc;font-weight:bold;">int</span> rightSum = Math.Max(<span style="color:#098658;">0</span>, Solve(root.right));

        <span style="color:#008000;">// Total path length needs to be calculated as</span>
        <span style="color:#008000;">// path length =&gt; leftPath + RightPath + currentNode</span>
        <span style="color:#0066cc;font-weight:bold;">int</span> pathSum = root.val + leftSum + rightSum;

        <span style="color:#008000;">// Updating maxPathLength</span>
        maxPathVal = Math.Max(maxPathVal, pathSum);

        <span style="color:#008000;">// Returnig single path as at a time either left or right needs to be picked</span>
        <span style="color:#008000;">// To contribute in current Node path. whichever is maximum</span>
        <span style="color:#0066cc;font-weight:bold;">return</span> Math.Max(leftSum, rightSum) + root.val;
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.8. Max Width Binary Tree</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root of a binary tree, return the maximum width of the given tree.

The maximum width of a tree is the maximum width among all levels. The width of a level is determined by measuring the distance between its end nodes, which are the leftmost and rightmost non-null nodes. The length calculation additionally takes into account the null nodes that would be present between the end nodes if a full binary tree were to stretch down to that level.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int data;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int val) { data = val; left = null, right = null }
 * }
 **/</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> widthOfBinaryTree(<span style="color:#008000;font-weight:bold;">TreeNode</span> root)
    {
        <span style="color:#008000;">// Approach: we will be using the Level Order Traversal</span>
        <span style="color:#008000;">// Then apply the Indexing formula to identify the child index position in Level order as if it was a complete binary tree</span>
        <span style="color:#008000;">// for 1 based index: leftChild pos = 2*ParentIndex, rightChild = 2*ParentIndex+1</span>

        <span style="color:#0066cc;font-weight:bold;">int</span> res = <span style="color:#098658;">0</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> res;

        <span style="color:#008000;font-weight:bold;">Queue</span>&lt;Tuple&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>,<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; q = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Queue</span>&lt;Tuple&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>, <span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;();
        q.Enqueue(Tuple.Create(root, <span style="color:#098658;">0</span>));

        <span style="color:#0066cc;font-weight:bold;">while</span>(q.Count &gt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">int</span> size = q.Count;
            <span style="color:#0066cc;font-weight:bold;">int</span> first = <span style="color:#098658;">0</span>;
            <span style="color:#0066cc;font-weight:bold;">int</span> last = <span style="color:#098658;">0</span>;

            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;size; i++)
            {
                <span style="color:#0066cc;font-weight:bold;">var</span> curr = q.Dequeue();
                <span style="color:#0066cc;font-weight:bold;">int</span> idx = curr.Item2;
                <span style="color:#0066cc;font-weight:bold;">var</span> node = curr.Item1;

                <span style="color:#0066cc;font-weight:bold;">if</span>(i == <span style="color:#098658;">0</span>) first = idx;
                <span style="color:#0066cc;font-weight:bold;">if</span>(i == size-<span style="color:#098658;">1</span>) last = idx;

                <span style="color:#0066cc;font-weight:bold;">if</span>(node.left != null)
                {
                    q.Enqueue(Tuple.Create(node.left, idx*<span style="color:#098658;">2</span>));
                }

                <span style="color:#0066cc;font-weight:bold;">if</span>(node.right != null)
                {
                    q.Enqueue(Tuple.Create(node.right, idx*<span style="color:#098658;">2</span>+<span style="color:#098658;">1</span>));
                }
                
            }

            res = Math.Max(res, last - first + <span style="color:#098658;">1</span>);
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.9. Min Time To Burn BTFrom Target</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a target node data and a root of binary tree. If the target is set on fire, determine the shortest amount of time needed to burn the entire binary tree.

It is known that in 1 second all nodes connected to a given node get burned. That is its left child, right child, and parent.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/*
 // Definition for a binary tree node.
 public class TreeNode {
     public int val;
     public TreeNode left;
     public TreeNode right;

     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {
         this.val = val;
         this.left = left;
         this.right = right;
     }
 }
*/</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">int</span> TimeToBurnTree(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#0066cc;font-weight:bold;">int</span> start) {
       <span style="color:#008000;">// Approach: Store the parent from target till the root node</span>
       <span style="color:#008000;">// now start buring the node fron target </span>
       <span style="color:#008000;">// Traverse in all the directions(left, right, parent)</span>
       <span style="color:#008000;">// the longest direction means till the BFS queue is not empty keep iterating</span>

       <span style="color:#008000;">// 1. BFS to Store the parent</span>
       <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>, <span style="color:#008000;font-weight:bold;">TreeNode</span>&gt; parentMap = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>, <span style="color:#008000;font-weight:bold;">TreeNode</span>&gt;();
       <span style="color:#008000;font-weight:bold;">Queue</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>&gt; q = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Queue</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>&gt;();
       <span style="color:#008000;font-weight:bold;">TreeNode</span> startNode = null;

       <span style="color:#0066cc;font-weight:bold;">if</span>(root != null)
       {
            q.Enqueue(root);
       }

       <span style="color:#0066cc;font-weight:bold;">while</span>(q.Count &gt; <span style="color:#098658;">0</span>)
       {
            <span style="color:#0066cc;font-weight:bold;">var</span> curr = q.Dequeue();
            <span style="color:#0066cc;font-weight:bold;">if</span>(curr.data == start)
            {
                startNode = curr;
            } 
            
            <span style="color:#0066cc;font-weight:bold;">if</span>(curr.left != null)
            {
                parentMap[curr.left] = curr;
                q.Enqueue(curr.left);
            }

            <span style="color:#0066cc;font-weight:bold;">if</span>(curr.right != null)
            {
                parentMap[curr.right] = curr;
                q.Enqueue(curr.right);
            }
       }

       <span style="color:#008000;">// Clear the Queue to Reuse the existing Queue</span>
       <span style="color:#008000;">// BFS to calculate the burning time</span>
       q.Clear();
       <span style="color:#0066cc;font-weight:bold;">int</span> time = <span style="color:#098658;">0</span>;
       <span style="color:#008000;font-weight:bold;">HashSet</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>&gt; visited = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">HashSet</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>&gt;();

        <span style="color:#0066cc;font-weight:bold;">if</span>(startNode != null)
        {
            q.Enqueue(startNode);
            visited.Add(startNode);
        }

        <span style="color:#0066cc;font-weight:bold;">while</span>(q.Count &gt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">int</span> size = q.Count;
            <span style="color:#008000;">// This condition is required to track if any new node is burned or not ?</span>
            <span style="color:#0066cc;font-weight:bold;">bool</span> burned = false;

            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt; size; i++)
            {
                <span style="color:#0066cc;font-weight:bold;">var</span> curr = q.Dequeue();

                <span style="color:#0066cc;font-weight:bold;">if</span>(curr.left != null &amp;&amp; !visited.Contains(curr.left))
                {
                    q.Enqueue(curr.left);
                    visited.Add(curr.left);
                    burned = true;
                }

                <span style="color:#0066cc;font-weight:bold;">if</span>(curr.right != null &amp;&amp; !visited.Contains(curr.right))
                {
                    q.Enqueue(curr.right);
                    visited.Add(curr.right);
                    burned = true;
                }

                <span style="color:#0066cc;font-weight:bold;">if</span>(parentMap.ContainsKey(curr) &amp;&amp; !visited.Contains(parentMap[curr]))
                {
                    q.Enqueue(parentMap[curr]);
                    visited.Add(parentMap[curr]);
                    burned = true;
                }
            }

            <span style="color:#0066cc;font-weight:bold;">if</span>(burned)
                time++;
        }
       
        <span style="color:#0066cc;font-weight:bold;">return</span> time;
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.10. Print Nodes At KDistance From Target</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root of a binary tree, the value of a target node target, and an integer k. Return an array of the values of all nodes that have a distance k from the target node.

The answer can be returned in any order (N represents null).

Note: Although input shows target as a value, internally it refers to the TreeNode with that value.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int data;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int val) { data = val; left = null, right = null }
 * }
 */</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; distanceK(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">TreeNode</span> target, <span style="color:#0066cc;font-weight:bold;">int</span> k)
    {
        <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#008000;font-weight:bold;">TreeNode</span>&gt; parentMap = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Dictionary</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#008000;font-weight:bold;">TreeNode</span>&gt;();

        <span style="color:#008000;font-weight:bold;">Queue</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>&gt; q = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Queue</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>&gt;();
        <span style="color:#0066cc;font-weight:bold;">if</span>(root != null)
            q.Enqueue(root);

        <span style="color:#0066cc;font-weight:bold;">while</span>(q.Count &gt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">var</span> node = q.Dequeue();
            <span style="color:#0066cc;font-weight:bold;">if</span>(node.left != null) 
            {
                q.Enqueue(node.left);
                parentMap[node.left.data] = node;
            }
            <span style="color:#0066cc;font-weight:bold;">if</span>(node.right != null) 
            {
                q.Enqueue(node.right);
                parentMap[node.right.data] = node;
            }

            <span style="color:#008000;">// if(node.data == target.data) break;</span>
        }
        
        <span style="color:#008000;">// Now start from the target node and traverse its neighbours(leftChild, rightChild, parent)</span>
        <span style="color:#008000;">// User BFS traversal using queue</span>
        <span style="color:#008000;">// Maintain visited nodes as it will again revisit the parent node and then again its child</span>

        q.Clear();
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; nodesToPrint = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
        <span style="color:#0066cc;font-weight:bold;">int</span> distance = <span style="color:#098658;">0</span>;
        <span style="color:#008000;font-weight:bold;">HashSet</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; visited = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">HashSet</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        <span style="color:#0066cc;font-weight:bold;">if</span>(target != null)
        {
            q.Enqueue(target);
            visited.Add(target.data);
        }

        <span style="color:#0066cc;font-weight:bold;">while</span>(q.Count &gt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(distance == k)
            {
                <span style="color:#0066cc;font-weight:bold;">while</span>(q.Count &gt; <span style="color:#098658;">0</span>)
                {
                    nodesToPrint.Add(q.Dequeue().data);
                }
                <span style="color:#0066cc;font-weight:bold;">return</span> nodesToPrint;
            }

            <span style="color:#0066cc;font-weight:bold;">int</span> size = q.Count;

            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;size; i++)
            {
                <span style="color:#0066cc;font-weight:bold;">var</span> curr = q.Dequeue();

                <span style="color:#0066cc;font-weight:bold;">if</span>(parentMap.ContainsKey(curr.data) &amp;&amp; !visited.Contains(parentMap[curr.data].data))
                {
                    q.Enqueue(parentMap[curr.data]);
                    visited.Add(parentMap[curr.data].data);
                }

                <span style="color:#0066cc;font-weight:bold;">if</span>(curr.left != null &amp;&amp; !visited.Contains(curr.left.data))
                {
                    q.Enqueue(curr.left);
                    visited.Add(curr.left.data);
                }

                <span style="color:#0066cc;font-weight:bold;">if</span>(curr.right != null &amp;&amp; !visited.Contains(curr.right.data))
                {
                    q.Enqueue(curr.right);
                    visited.Add(curr.right.data);
                }
            }
            distance++;
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> nodesToPrint;
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.11. Print Root To Leaf BT</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root of a binary tree. Return all the root-to-leaf paths in the binary tree.

A leaf node of a binary tree is the node which does not have a left and right child.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int data;
 *     public TreeNode left;
 *     public TreeNode right;
 *      public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {
 *          this.data = val;
 *          this.left = left;
 *          this.right = right;
 *      }
 * }
 */</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; AllRootToLeaf(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#008000;">// Your code goes here</span>

        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;();

        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> res;
        Traverse(root, res, <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;());
        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> Traverse(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; res, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; path)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span>;

        <span style="color:#008000;">// Adding the node data here as if it is the leaf node it should be included</span>
        path.Add(root.data);

        <span style="color:#008000;">// Checking if its a leaf node then add the current Path</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(root.left == null &amp;&amp; root.right == null)
        {
            <span style="color:#0066cc;font-weight:bold;">var</span> lst = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;(path);
            res.Add(lst);

            <span style="color:#008000;">// Once Path is added then leaf node is the one which should be removed in the 1st place during backtracking</span>
            path.RemoveAt(path.Count-<span style="color:#098658;">1</span>);
            <span style="color:#0066cc;font-weight:bold;">return</span>;
        }
        
        Traverse(root.left, res, path);
        Traverse(root.right, res, path);
        path.RemoveAt(path.Count-<span style="color:#098658;">1</span>);
    }
}</pre>
<h4 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.12. Symmetrical BT</h4>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">bool</span> IsSymmetric(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(root.left, root.right);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">bool</span> Solve(<span style="color:#008000;font-weight:bold;">TreeNode</span> root1, <span style="color:#008000;font-weight:bold;">TreeNode</span> root2)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root1 == null &amp;&amp; root2 == null) <span style="color:#0066cc;font-weight:bold;">return</span> true;

        <span style="color:#0066cc;font-weight:bold;">if</span>(root1 == null || root2 == null) <span style="color:#0066cc;font-weight:bold;">return</span> false;

        <span style="color:#0066cc;font-weight:bold;">if</span>(root1.data != root2.data) <span style="color:#0066cc;font-weight:bold;">return</span> false;

        <span style="color:#0066cc;font-weight:bold;">return</span> Solve(root1.left, root2.right) &amp;&amp; Solve(root1.right, root2.left);
    }
}</pre>
<h3 style='color:#009900; margin-top:25px; margin-bottom:12px; border-bottom:2px solid #009900; padding-bottom:8px;'>üìÅ 5.13. Traversal</h3>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.13.1. Boundary Traversal</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given a root of Binary Tree, perform the boundary traversal of the tree. 

The boundary traversal is the process of visiting the boundary nodes of the binary tree in the anticlockwise direction, starting from the root.

The boundary of a binary tree is the concatenation of the root, the left boundary, the leaves ordered from left-to-right, and the reverse order of the right boundary.

The left boundary is the set of nodes defined by the following:

The root node&#x27;s left child is in the left boundary. If the root does not have a left child, then the left boundary is empty.

If a node in the left boundary and has a left child, then the left child is in the left boundary.

If a node is in the left boundary, has no left child, but has a right child, then the right child is in the left boundary.

The leftmost leaf is not in the left boundary.

The right boundary is similar to the left boundary, except it is the right side of the root&#x27;s right subtree. Again, the leaf is not part of the right boundary, and the right boundary is empty if the root does not have a right child.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; Boundary(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#008000;">// 1. Add LeftBoundary</span>
        <span style="color:#008000;">// 2. Add Leaf Nodes for left subtree</span>
        <span style="color:#008000;">// 3. Add Leaf Nodes for right subtree</span>
        <span style="color:#008000;">// 4. Add RightBoundary</span>

        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        <span style="color:#008000;">// Checking if given root node is null then simply return empty list</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> res;

        res.Add(root.data);
        <span style="color:#008000;">// Checking if rootNode is leafNode then we need to return the rootNode value only</span>
        <span style="color:#0066cc;font-weight:bold;">if</span>(root.left == null &amp;&amp; root.right == null) <span style="color:#0066cc;font-weight:bold;">return</span> res;

        AddLeftBoundary(root, res);
        AddLeafNodes(root, res);
        AddRightBoundary(root, res);

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> AddLeafNodes(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root.left == null &amp;&amp; root.right == null)
        {
            res.Add(root.data);
            <span style="color:#0066cc;font-weight:bold;">return</span>;
        }

        <span style="color:#0066cc;font-weight:bold;">if</span>(root.left != null)
            AddLeafNodes(root.left, res);
        <span style="color:#0066cc;font-weight:bold;">if</span>(root.right != null)
            AddLeafNodes(root.right, res);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> AddLeftBoundary(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root.left == null) <span style="color:#0066cc;font-weight:bold;">return</span>;

        <span style="color:#008000;font-weight:bold;">TreeNode</span> curr = root.left;
        <span style="color:#008000;">// res.Add(curr.data);</span>

        <span style="color:#0066cc;font-weight:bold;">while</span>(curr.left != null || curr.right != null)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(curr.left != null)
            {
                res.Add(curr.data);
                curr = curr.left;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span>(curr.right != null)
            {
                res.Add(curr.data);
                curr = curr.right;
            }
        }
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> AddRightBoundary(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root.right == null) <span style="color:#0066cc;font-weight:bold;">return</span>;

        <span style="color:#008000;font-weight:bold;">TreeNode</span> curr = root.right;
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; temp = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        <span style="color:#0066cc;font-weight:bold;">while</span>(curr.left != null || curr.right != null)
        {
            <span style="color:#0066cc;font-weight:bold;">if</span>(curr.right != null)
            {
                temp.Add(curr.data);
                curr = curr.right;
            }
            <span style="color:#0066cc;font-weight:bold;">else</span> <span style="color:#0066cc;font-weight:bold;">if</span>(curr.left != null)
            {
                temp.Add(curr.data);
                curr = curr.left;          
            }
        }

        <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=temp.Count-<span style="color:#098658;">1</span>; i&gt;=<span style="color:#098658;">0</span>; i--)
        {
            res.Add(temp[i]);
        }

    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.13.2. In Order Traversal</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
*
 * Definition for a binary tree node.
 * public class TreeNode 
 * }
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; Inorder(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#008000;">//your code goes here</span>
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        Traverse(root, res);
        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> Traverse(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span>;

        Traverse(root.left, res);
        res.Add(root.data);
        Traverse(root.right, res);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.13.3. Level Order Traversal</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Approach 1: Using BFS and Tuple (level, Node) in Queue
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; levelOrder(<span style="color:#008000;font-weight:bold;">TreeNode</span> root)
    {
        <span style="color:#008000;">//your code goes here</span>

        <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;();

        <span style="color:#0066cc;font-weight:bold;">if</span> (root == null) <span style="color:#0066cc;font-weight:bold;">return</span> res;

        <span style="color:#008000;font-weight:bold;">Queue</span>&lt;(<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#008000;font-weight:bold;">TreeNode</span>)&gt; q = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Queue</span>&lt;(<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#008000;font-weight:bold;">TreeNode</span>)&gt;();

        q.Enqueue((<span style="color:#098658;">0</span>, root));


        <span style="color:#0066cc;font-weight:bold;">while</span> (q.Count &gt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#0066cc;font-weight:bold;">var</span> node = q.Dequeue();

            <span style="color:#0066cc;font-weight:bold;">if</span> (node.Item1 &gt;= res.Count)
            {
                res.Add(<span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;());
            }

            res[node.Item1].Add(node.Item2.data);

            <span style="color:#0066cc;font-weight:bold;">if</span> (node.Item2.left != null)
            {
                q.Enqueue((node.Item1 + <span style="color:#098658;">1</span>, node.Item2.left));
                <span style="color:#008000;">// res[node.item1].Add(node.item2.left.data);</span>
            }

            <span style="color:#0066cc;font-weight:bold;">if</span> (node.Item2.right != null)
            {
                q.Enqueue((node.Item1 + <span style="color:#098658;">1</span>, node.Item2.right));
                <span style="color:#008000;">// res[node.item1].Add(node.item2.right.data);</span>
            }
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }
}

<span style="color:#008000;">// Approach 2: Recursive </span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; LevelOrder(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        
        <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;();
        Traverse(root, res, <span style="color:#098658;">1</span>);
        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> Traverse(<span style="color:#008000;font-weight:bold;">TreeNode</span> node, <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; result, <span style="color:#0066cc;font-weight:bold;">int</span> level)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(node == null)
            <span style="color:#0066cc;font-weight:bold;">return</span>;
        
        <span style="color:#0066cc;font-weight:bold;">if</span>(result.Count &lt; level)
        {
            result.Add(<span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;());
        }
        result[level-<span style="color:#098658;">1</span>].Add(node.data);
        Traverse(node.left, result, level+<span style="color:#098658;">1</span>);
        Traverse(node.right, result, level+<span style="color:#098658;">1</span>);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.13.4. Post Order Traversal</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
*
 * Definition for a binary tree node.
 * public class TreeNode 
 * }
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; postorder(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#008000;">// Your code goes here</span>

        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();
        Traverse(root, res);

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> Traverse(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span>;

        Traverse(root.left, res);
        Traverse(root.right, res);
        res.Add(root.data);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.13.5. Pre Order Traversal</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
*
 * Definition for a binary tree node.
 * public class TreeNode 
 * }
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; Preorder(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#008000;">//your code goes here</span>
        <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        Traverse(root, res);

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> Traverse(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; res)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span>;

        res.Add(root.data);
        Traverse(root.left, res);
        Traverse(root.right, res);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.13.6. Top View DFS</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root of a binary tree, return the top view of the binary tree.

Top view of a binary tree is the set of nodes visible when the tree is viewed from the top. Return nodes from the leftmost node to the rightmost node. Also if 2 nodes are outside the shadow of the tree and are at the same position then consider the left ones only(i.e. leftmost).
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int data;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int val) { data = val; left = null, right = null }
 * }
 **/</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt; TopView(<span style="color:#008000;font-weight:bold;">TreeNode</span> root)
    {
        SortedDictionary&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#0066cc;font-weight:bold;">int</span>&gt; dict = <span style="color:#0066cc;font-weight:bold;">new</span> SortedDictionary&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#0066cc;font-weight:bold;">int</span>&gt;();

        Traverse(root, dict, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>);

        <span style="color:#0066cc;font-weight:bold;">return</span> dict.Values.ToList();

    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> Traverse(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, SortedDictionary&lt;<span style="color:#0066cc;font-weight:bold;">int</span>,<span style="color:#0066cc;font-weight:bold;">int</span>&gt; dict, <span style="color:#0066cc;font-weight:bold;">int</span> row, <span style="color:#0066cc;font-weight:bold;">int</span> col)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span>;

        <span style="color:#0066cc;font-weight:bold;">if</span>(!dict.ContainsKey(col))
        {
            dict.Add(col, root.data);
        }

        Traverse(root.left, dict, row+<span style="color:#098658;">1</span>, col-<span style="color:#098658;">1</span>);
        Traverse(root.right, dict, row+<span style="color:#098658;">1</span>, col+<span style="color:#098658;">1</span>);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.13.7. Vertical Order Traversal</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Compute the binary tree&#x27;s vertical order traversal given its root.

The left and right children of a node at location (row, col) will be at (row + 1, col - 1) and (row + 1, col + 1), respectively. The tree&#x27;s root is located at (0, 0).

The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values. Return the binary tree&#x27;s vertical order traversal.
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution
{
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; VerticalTraversal(<span style="color:#008000;font-weight:bold;">TreeNode</span> root)
    {
         <span style="color:#0066cc;font-weight:bold;">var</span> res = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;();
        <span style="color:#0066cc;font-weight:bold;">if</span> (root == null) <span style="color:#0066cc;font-weight:bold;">return</span> res;

        <span style="color:#008000;">// SortedDictionary: column -&gt; List of (row, value) as Tuple&lt;int, int&gt;</span>
        <span style="color:#0066cc;font-weight:bold;">var</span> dict = <span style="color:#0066cc;font-weight:bold;">new</span> SortedDictionary&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#008000;font-weight:bold;">List</span>&lt;Tuple&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;&gt;();

        Traverse(root, <span style="color:#098658;">0</span>, <span style="color:#098658;">0</span>, dict);

        <span style="color:#0066cc;font-weight:bold;">foreach</span> (<span style="color:#0066cc;font-weight:bold;">var</span> key <span style="color:#0066cc;font-weight:bold;">in</span> dict.Keys)
        {
            <span style="color:#008000;">// Sort by row, then value</span>
            <span style="color:#0066cc;font-weight:bold;">var</span> sorted = dict[key]
                .OrderBy(x =&gt; x.Item1) <span style="color:#008000;">// Item1 is row</span>
                .ThenBy(x =&gt; x.Item2)  <span style="color:#008000;">// Item2 is value</span>
                .Select(x =&gt; x.Item2)  <span style="color:#008000;">// Select the value</span>
                .ToList();
            res.Add(sorted);
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#0066cc;font-weight:bold;">void</span> Traverse(<span style="color:#008000;font-weight:bold;">TreeNode</span> node, <span style="color:#0066cc;font-weight:bold;">int</span> row, <span style="color:#0066cc;font-weight:bold;">int</span> col, SortedDictionary&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#008000;font-weight:bold;">List</span>&lt;Tuple&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;&gt; dict)
    {
        <span style="color:#0066cc;font-weight:bold;">if</span> (node == null) <span style="color:#0066cc;font-weight:bold;">return</span>;
        <span style="color:#0066cc;font-weight:bold;">if</span> (!dict.ContainsKey(col))
        {
            dict[col] = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;Tuple&lt;<span style="color:#0066cc;font-weight:bold;">int</span>, <span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;();
        }
        dict[col].Add(Tuple.Create(row, node.val));

        Traverse(node.left, row + <span style="color:#098658;">1</span>, col - <span style="color:#098658;">1</span>, dict);
        Traverse(node.right, row + <span style="color:#098658;">1</span>, col + <span style="color:#098658;">1</span>, dict);
    }
}</pre>
<h5 style='color:#0066cc; margin-top:20px; margin-bottom:10px;'>5.13.8. Zig Zag Or Spiral Traversal</h5>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üìã Problem Statement</h5>
<blockquote style='color:#555; font-style:italic; border-left:4px solid #0066cc; padding-left:15px; margin:10px 0; line-height:1.6;'>
Given the root of a binary tree, return the zigzag level order traversal of its nodes&#x27; values. 
(i.e., from left to right, then right to left for the next level and alternate between).
</blockquote>
<h5 style='color:#333; margin-top:15px; margin-bottom:8px;'>üíª Solution</h5>
<pre style='background-color:#f5f5f5; border:1px solid #ddd; border-radius:4px; padding:12px; overflow-x:auto; font-family:"Courier New", monospace; font-size:12px; line-height:1.4;'><span style="color:#008000;">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int data;
 *     public TreeNode left;
 *     public TreeNode right;
 *     TreeNode(int val) { data = val; left = null, right = null }
 * }
 */</span>

<span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#0066cc;font-weight:bold;">class</span> Solution {
    <span style="color:#0066cc;font-weight:bold;">public</span> <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; ZigzagLevelOrder(<span style="color:#008000;font-weight:bold;">TreeNode</span> root) {
        <span style="color:#008000;">//your code goes here</span>
        <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; result = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">List</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt;();
        <span style="color:#0066cc;font-weight:bold;">if</span>(root == null) <span style="color:#0066cc;font-weight:bold;">return</span> result;

        <span style="color:#0066cc;font-weight:bold;">return</span> Traverse(root, result, true);
    }

    <span style="color:#0066cc;font-weight:bold;">private</span> <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; Traverse(<span style="color:#008000;font-weight:bold;">TreeNode</span> root, <span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#008000;font-weight:bold;">IList</span>&lt;<span style="color:#0066cc;font-weight:bold;">int</span>&gt;&gt; res, <span style="color:#0066cc;font-weight:bold;">bool</span> isLeftToRight)
    {
        <span style="color:#008000;font-weight:bold;">Queue</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>&gt; q = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#008000;font-weight:bold;">Queue</span>&lt;<span style="color:#008000;font-weight:bold;">TreeNode</span>&gt;();
        q.Enqueue(root);

        <span style="color:#0066cc;font-weight:bold;">while</span>(q.Count &gt; <span style="color:#098658;">0</span>)
        {
            <span style="color:#008000;">// This is something which is helping to maintain same queue and still able to distingues level nodes</span>
            <span style="color:#0066cc;font-weight:bold;">int</span> size = q.Count;

            <span style="color:#008000;">// Maintain an array to store the level nodes values to add in result List</span>
            <span style="color:#0066cc;font-weight:bold;">int</span>[] levelArray = <span style="color:#0066cc;font-weight:bold;">new</span> <span style="color:#0066cc;font-weight:bold;">int</span>[size];
            
            <span style="color:#0066cc;font-weight:bold;">for</span>(<span style="color:#0066cc;font-weight:bold;">int</span> i=<span style="color:#098658;">0</span>; i&lt;size; i++)
            {
                <span style="color:#0066cc;font-weight:bold;">var</span> node = q.Dequeue();

                <span style="color:#0066cc;font-weight:bold;">if</span>(isLeftToRight)
                {
                    levelArray[i] = node.data;
                }
                <span style="color:#0066cc;font-weight:bold;">else</span>
                {
                    levelArray[size-i-<span style="color:#098658;">1</span>] = node.data;
                }

                <span style="color:#0066cc;font-weight:bold;">if</span>(node.left != null)
                {
                    q.Enqueue(node.left);
                }
                <span style="color:#0066cc;font-weight:bold;">if</span>(node.right != null)
                {
                    q.Enqueue(node.right);
                }
            }

            isLeftToRight = !isLeftToRight;
            <span style="color:#008000;">// Now one level has been completed. Add all the traversed array in the result list</span>
            res.Add(levelArray.ToList());
        }

        <span style="color:#0066cc;font-weight:bold;">return</span> res;
    }
}</pre>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>
<hr style='border:none; border-top:1px solid #ddd; margin:20px 0;'>

</body>
</html>
